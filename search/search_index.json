{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastCRUD","text":"<p> Powerful CRUD methods and automatic endpoint creation for FastAPI. </p> <p> </p> <p> FastCRUD is a Python package for FastAPI, offering robust async CRUD operations and flexible endpoint creation utilities, streamlined through advanced features like auto-detected join conditions, dynamic sorting, and offset and cursor pagination. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully Async: Leverages Python's async capabilities for non-blocking database operations.</li> <li>SQLAlchemy 2.0: Works with the latest SQLAlchemy version for robust database interactions.</li> <li>SQLModel Support: You can optionally use SQLModel 0.14 or newer instead of SQLAlchemy.</li> <li>Powerful CRUD Functionality: Full suite of efficient CRUD operations with support for joins.</li> <li>Dynamic Query Building: Supports building complex queries dynamically, including filtering, sorting, and pagination.</li> <li>Advanced Join Operations: Facilitates performing SQL joins with other models with automatic join condition detection.</li> <li>Built-in Offset Pagination: Comes with ready-to-use offset pagination.</li> <li>Cursor-based Pagination: Implements efficient pagination for large datasets, ideal for infinite scrolling interfaces.</li> <li>Modular and Extensible: Designed for easy extension and customization to fit your requirements.</li> <li>Auto-generated Endpoints: Streamlines the process of adding CRUD endpoints with custom dependencies and configurations.</li> </ul>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your model, schemas and database connection:</p> <pre><code># imports here\n\n# define your model\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n# your schemas\nclass ItemSchema(BaseModel):\n    name: str\n\n# database connection\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> <pre><code>from fastcrud import crud_router\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy or SQLModel: FastCRUD uses SQLAlchemy 2.0 for database operations, so you need SQLAlchemy 2.0 or newer or SQLModel 0.14 or newer.</li> <li>Pydantic V2 or SQLModel: FastCRUD leverages Pydantic models for data validation and serialization, so you need Pydantic 2.0 or newer or SQLModel 0.14 or newer.</li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>pip install fastcrud\n</code></pre> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>FastCRUD offers two primary ways to use its functionalities:</p> <ol> <li>By using <code>crud_router</code> for automatic endpoint creation.</li> <li>By integrating <code>FastCRUD</code> directly into your FastAPI endpoints for more control.</li> </ol> <p>Below are examples demonstrating both approaches:</p>"},{"location":"#using-crud_router-for-automatic-endpoint-creation","title":"Using crud_router for Automatic Endpoint Creation","text":"<p>Here's a quick example to get you started:</p>"},{"location":"#define-your-model-and-schema","title":"Define Your Model and Schema","text":"models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"#set-up-fastapi-and-fastcrud","title":"Set Up FastAPI and FastCRUD","text":"main.py<pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import crud_router\nfrom fastcrud import FastCRUD\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom item import Base, Item, ItemCreateSchema, ItemUpdateSchema\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\ncrud = FastCRUD(Item)\n\n# CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemCreateSchema,\n    update_schema=ItemUpdateSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"#using-fastcrud-in-user-defined-fastapi-endpoints","title":"Using FastCRUD in User-Defined FastAPI Endpoints","text":"<p>For more control over your endpoints, you can use FastCRUD directly within your custom FastAPI route functions. Here's an example:</p> api/v1/item.py<pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastcrud import FastCRUD\nfrom yourapp.models import Item\nfrom yourapp.schemas import ItemCreateSchema, ItemUpdateSchema\n\n# Assume async_session is already set up as per the previous example\n\n# Instantiate FastCRUD with your model\nitem_crud = FastCRUD(Item)\n\n@app.post(\"/custom/items/\")\nasync def create_item(item_data: ItemCreateSchema, db: AsyncSession = Depends(get_session)):\n    return await item_crud.create(db, item_data)\n\n@app.get(\"/custom/items/{item_id}\")\nasync def read_item(item_id: int, db: AsyncSession = Depends(get_session)):\n    item = await item_crud.get(db, id=item_id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item\n\n# You can add more routes for update and delete operations in a similar fashion\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>MIT</code></p>"},{"location":"changelog/","title":"FastCRUD Changelog","text":""},{"location":"changelog/#introduction","title":"Introduction","text":"<p>The Changelog documents all notable changes made to FastCRUD. This includes new features, bug fixes, and improvements. It's organized by version and date, providing a clear history of the library's development.</p>"},{"location":"changelog/#0130-may-28-2024","title":"[0.13.0] - May 28, 2024","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Filters in Automatic Endpoints \ud83c\udf89</li> <li>One-to-many support in joins</li> <li>Upsert method in FastCRUD class by @dubusster </li> </ul>"},{"location":"changelog/#detailed-changes","title":"Detailed Changes","text":""},{"location":"changelog/#using-filters-in-fastcrud","title":"Using Filters in FastCRUD","text":"<p>FastCRUD provides filtering capabilities, allowing you to filter query results based on various conditions. Filters can be applied to <code>read_multi</code> and <code>read_paginated</code> endpoints. This section explains how to configure and use filters in FastCRUD.</p>"},{"location":"changelog/#defining-filters","title":"Defining Filters","text":"<p>Filters are either defined using the <code>FilterConfig</code> class or just passed as a dictionary. This class allows you to specify default filter values and validate filter types. Here's an example of how to define filters for a model:</p> <pre><code>from fastcrud import FilterConfig\n\n# Define filter configuration for a model\nfilter_config = FilterConfig(\n    tier_id=None,  # Default filter value for tier_id\n    name=None  # Default filter value for name\n)\n</code></pre> <p>And the same thing using a <code>dict</code>: <pre><code>filter_config = {\n    \"tier_id\": None,  # Default filter value for tier_id\n    \"name\": None,  # Default filter value for name\n}\n</code></pre></p> <p>By using <code>FilterConfig</code> you get better error messages.</p>"},{"location":"changelog/#applying-filters-to-endpoints","title":"Applying Filters to Endpoints","text":"<p>You can apply filters to your endpoints by passing the <code>filter_config</code> to the <code>crud_router</code> or <code>EndpointCreator</code>. Here's an example:</p> <pre><code>from fastcrud import crud_router\nfrom yourapp.models import YourModel\nfrom yourapp.schemas import CreateYourModelSchema, UpdateYourModelSchema\nfrom yourapp.database import async_session\n\n# Apply filters using crud_router\napp.include_router(\n    crud_router(\n        session=async_session,\n        model=YourModel,\n        create_schema=CreateYourModelSchema,\n        update_schema=UpdateYourModelSchema,\n        filter_config=filter_config,  # Apply the filter configuration\n        path=\"/yourmodel\",\n        tags=[\"YourModel\"]\n    )\n)\n</code></pre>"},{"location":"changelog/#using-filters-in-requests","title":"Using Filters in Requests","text":"<p>Once filters are configured, you can use them in your API requests. Filters are passed as query parameters. Here's an example of how to use filters in a request to a paginated endpoint:</p> <pre><code>GET /yourmodel/get_paginated?page=1&amp;itemsPerPage=3&amp;tier_id=1&amp;name=Alice\n</code></pre>"},{"location":"changelog/#custom-filter-validation","title":"Custom Filter Validation","text":"<p>The <code>FilterConfig</code> class includes a validator to check filter types. If an invalid filter type is provided, a <code>ValueError</code> is raised. You can customize the validation logic by extending the <code>FilterConfig</code> class:</p> <pre><code>from fastcrud import FilterConfig\nfrom pydantic import ValidationError\n\nclass CustomFilterConfig(FilterConfig):\n    @field_validator(\"filters\")\n    def check_filter_types(cls, filters: dict[str, Any]) -&gt; dict[str, Any]:\n        for key, value in filters.items():\n            if not isinstance(value, (type(None), str, int, float, bool)):\n                raise ValueError(f\"Invalid default value for '{key}': {value}\")\n        return filters\n\ntry:\n    # Example of invalid filter configuration\n    invalid_filter_config = CustomFilterConfig(invalid_field=[])\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"changelog/#handling-invalid-filter-columns","title":"Handling Invalid Filter Columns","text":"<p>FastCRUD ensures that filters are applied only to valid columns in your model. If an invalid filter column is specified, a <code>ValueError</code> is raised:</p> <pre><code>try:\n    # Example of invalid filter column\n    invalid_filter_config = FilterConfig(non_existent_column=None)\nexcept ValueError as e:\n    print(e)  # Output: Invalid filter column 'non_existent_column': not found in model\n</code></pre>"},{"location":"changelog/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>one-to-one</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"changelog/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul> <p>Example</p> <p>Let's define two tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <p>Fetch a user and their tier:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre> <p>One-to-One Relationship with Nested Joins</p> <p>To get the joined data in a nested dictionary:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre>"},{"location":"changelog/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>[!WARNING] When using <code>nest_joins=True</code>, the performance will always be a bit worse than when using <code>nest_joins=False</code>. For cases where more performance is necessary, consider using <code>nest_joins=False</code> and remodeling your database.</p> <p>Example</p> <p>To demonstrate a one-to-many relationship, let's assume <code>User</code> and <code>Post</code> tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary key=True)\n    name = Column(String)\n\nclass Post(Base):\n    __tablename__ = \"post\"\n    id = Column(Integer, primary key=True)\n    user_id = Column(Integer, ForeignKey(\"user.id\"))\n    content = Column(String)\n</code></pre> <p>Fetch a user and all their posts:</p> <pre><code>user_posts = await user_crud.get_joined(\n    db=db,\n    join_model=Post,\n    join_on=User.id == Post.user_id,\n    join_type=\"left\",\n    join_prefix=\"post_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example User\",\n    \"posts\": [\n        {\n            \"id\": 101,\n            \"user_id\": 1,\n            \"content\": \"First post content\"\n        },\n        {\n            \"id\": 102,\n            \"user_id\": 1,\n            \"content\": \"Second post content\"\n        }\n    ]\n}\n</code></pre>"},{"location":"changelog/#whats-changed","title":"What's Changed","text":"<ul> <li>feat: \u2728 add upsert method in FastCRUD class by @dubusster</li> <li>Filters in Automatic Endpoints</li> <li>One-to-many support in joins</li> <li>tests fixed by @mithun2003</li> <li>Using the same session for all tests</li> <li>warning added to docs</li> </ul> <p>Full Changelog: https://github.com/mithun2003/CRUDFastAPI/compare/v0.12.1...v0.13.0</p>"},{"location":"changelog/#0121-may-10-2024","title":"[0.12.1] - May 10, 2024","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Deprecation Warning for dependency handling.</li> </ul>"},{"location":"changelog/#detailed-changes_1","title":"Detailed Changes","text":"<p>If you pass a sequence of <code>params.Depends</code> type variables to any <code>*_deps</code> parameter in <code>EndpointCreator</code> and <code>crud_router</code>, you'll get a warning. Support will be completely removed in 0.15.0.</p> <p>Full Changelog: https://github.com/mithun2003/CRUDFastAPI/compare/v0.12.0...v0.12.1</p>"},{"location":"changelog/#0120-may-8-2024","title":"[0.12.0] - May 8, 2024","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Unpaginated versions of multi-row get methods by @slaarti in #62  \ud83c\udf89</li> <li>Nested Join bug fixes</li> <li>Dependency handling now working as docs say</li> <li>Option to Skip commit in some fastcrud methods</li> <li>Docstring example fixes</li> <li><code>__in</code> and <code>__not_in</code> filters by @JakNowy \ud83c\udf89</li> <li>Fastapi 0.111.0 support</li> </ul>"},{"location":"changelog/#detailed-changes_2","title":"Detailed Changes","text":""},{"location":"changelog/#unpaginated-versions-of-multi-row-get-methods","title":"Unpaginated versions of multi-row get methods","text":"<p>Now, if you pass <code>None</code> to <code>limit</code> in <code>get_multi</code> and <code>get_multi_joined</code>, you get the whole unpaginated set of data that matches the filters. Use this with caution.</p> <pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nitems = await crud_items.get_multi(db=db, limit=None)\n# this will return all items in the db\n</code></pre>"},{"location":"changelog/#dependency-handling-now-working-as-docs-say","title":"Dependency handling now working as docs say","text":"<p>Now, you may pass dependencies to <code>crud_router</code> or <code>EndpointCreator</code> as simple functions instead of needing to wrap them in <code>fastapi.Depends</code>.</p> <pre><code>from .dependencies import get_superuser\napp.include_router(\n    crud_router(\n        session=db,\n        model=Item,\n        create_schema=ItemCreate,\n        update_schema=ItemUpdate,\n        delete_schema=ItemDelete,\n        create_deps=[get_superuser],\n        update_deps=[get_superuser],\n        delete_deps=[get_superuser],\n        path=\"/item\",\n        tags=[\"item\"],\n    )\n)\n</code></pre>"},{"location":"changelog/#option-to-skip-commit-in-some-fastcrud-methods","title":"Option to Skip commit in some fastcrud methods","text":"<p>For <code>create</code>, <code>update</code>, <code>db_delete</code> and <code>delete</code> methods of <code>FastCRUD</code>, now you have the option of passing <code>commit=False</code> so you don't commit the operations immediately.</p> <pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\n\nawait crud_items.delete(\n    db=db, \n    commit=False, \n    id=1\n)\n# this will not actually delete until you run a db.commit()\n</code></pre>"},{"location":"changelog/#__in-and-__not_in-filters","title":"<code>__in</code> and <code>__not_in</code> filters","text":"<p>You may now pass <code>__in</code> and <code>__not_in</code> to methods that accept advanced queries:</p> <ul> <li><code>__gt</code>: greater than,</li> <li><code>__lt</code>: less than,</li> <li><code>__gte</code>: greater than or equal to,</li> <li><code>__lte</code>: less than or equal to,</li> <li><code>__ne</code>: not equal,</li> <li><code>__in</code>: included in [tuple, list or set],</li> <li><code>__not_in</code>: not included in [tuple, list or set].</li> </ul>"},{"location":"changelog/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Add unpaginated versions of multi-row get methods (w/tests) by @slaarti \ud83c\udf89</li> <li>Join fixes</li> <li>Dependencies</li> <li>Skip commit</li> <li>Docstring fix</li> <li>feat: filter __in by @JakNowy \ud83c\udf89</li> <li>python support for 0.111.0 added</li> <li>version bump in pyproject.toml for 0.12.0</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@slaarti made their first contribution in https://github.com/mithun2003/CRUDFastAPI/pull/62 \ud83c\udf89</li> </ul> <p>Full Changelog: https://github.com/mithun2003/CRUDFastAPI/compare/v0.11.1...v0.12.0</p>"},{"location":"changelog/#0111-apr-22-2024","title":"[0.11.1] - Apr 22, 2024","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>one_or_none</code> parameter to FastCRUD <code>get</code> method (default <code>False</code>)</li> <li><code>nest_joins</code> parameter to FastCRUD <code>get_joined</code> and <code>get_multi_joined</code> (default <code>False</code>)</li> </ul>"},{"location":"changelog/#detailed-changes_3","title":"Detailed Changes","text":""},{"location":"changelog/#get","title":"<code>get</code>","text":"<p>By default, the <code>get</code> method in <code>FastCRUD</code> returns the <code>first</code> object matching all the filters it finds.</p> <p>If you want to ensure the <code>one_or_none</code> behavior, you may pass the parameter as <code>True</code>:</p> <pre><code>crud.get(\n    async_session, \n    one_or_none=True, \n    category_id=1\n)\n</code></pre>"},{"location":"changelog/#get_joined-and-get_multi_joined","title":"<code>get_joined</code> and <code>get_multi_joined</code>","text":"<p>By default, <code>FastCRUD</code> joins all the data and returns it in a single dictionary. Let's define two tables: <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre></p> <p>And join them with <code>FastCRUD</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",,\n    id=1\n)\n</code></pre> <p>We'll get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\",\n}\n</code></pre> <p>Now, if you want the joined data in a nested dictionary instead, you may just pass <code>nest_joins=True</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>And you will get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\",\n    },\n}\n</code></pre> <p>This works for both <code>get_joined</code> and <code>get_multi_joined</code>.</p> <p>Warning</p> <p>Note that the final <code>\"_\"</code> in the passed <code>\"tier_\"</code> is stripped.</p>"},{"location":"changelog/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Reuse of <code>select</code> method in <code>FastCRUD</code></li> <li>Skip count call when possible</li> <li>Add <code>one_or_none</code> parameter to FastCRUD <code>get</code> method</li> <li>Add <code>nest_joins</code> parameter to FastCRUD <code>get_joined</code> and <code>get_multi_joined</code></li> </ul>"},{"location":"changelog/#new-contributors_1","title":"New Contributors","text":"<ul> <li>@JakNowy made their first contribution in PR #51.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0110-apr-7-2024","title":"[0.11.0] - Apr 7, 2024","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Multiple primary keys support, a significant enhancement by @dubusster in #31 \ud83c\udf89.</li> <li>Option to disable the count in <code>get_multi</code> and <code>get_multi_joined</code> methods for performance optimization.</li> <li>Fixes for a validation bug when <code>return_as_model</code> is set to <code>True</code>.</li> <li>Resolution of a bug concerning incorrect handling of <code>db_row</code> in methods.</li> <li>Correction of the <code>valid_methods</code> bug, which previously raised the wrong error type.</li> <li>Upgrade of <code>FastAPI</code> dependency to version <code>0.111.0</code>, ensuring compatibility with the latest FastAPI features.</li> <li>Achievement of 100% test coverage, with the addition of a workflow and badge to showcase this milestone.</li> <li>Inclusion of the changelog within the project documentation, providing a comprehensive history of changes directly to users.</li> </ul>"},{"location":"changelog/#detailed-changes_4","title":"Detailed Changes","text":""},{"location":"changelog/#multiple-primary-keys-support","title":"Multiple Primary Keys Support","text":"<p>FastCRUD now accommodates models with multiple primary keys, facilitating more complex database designs. For models defined with more than one primary key, the endpoint creator automatically generates paths reflecting the primary keys' order. This feature extends support to primary keys named differently than <code>id</code>, enhancing the flexibility of FastCRUD's routing capabilities.</p>"},{"location":"changelog/#example","title":"Example:","text":"<p>For a model with multiple primary keys, FastCRUD generates specific endpoints such as <code>/multi_pk/get/{id}/{uuid}</code>, accommodating the unique identification needs of complex data models.</p>"},{"location":"changelog/#optional-count","title":"Optional Count","text":"<p>The <code>get_multi</code> and <code>get_multi_joined</code> methods now feature an <code>return_total_count=False</code> parameter, allowing users to opt-out of receiving the total count in responses. This option can enhance performance by skipping potentially expensive count operations.</p>"},{"location":"changelog/#behavior","title":"Behavior:","text":"<ul> <li>By default, <code>return_total_count=True</code> is assumed, returning both data and a total count.</li> <li>When set to <code>False</code>, responses contain only the data array, omitting the total count for efficiency.</li> </ul>"},{"location":"changelog/#whats-changed_3","title":"What's Changed","text":"<ul> <li>Implementation of multiple primary keys support, addressing a significant flexibility requirement for advanced use cases.</li> <li>Introduction of optional count retrieval in multi-get methods, optimizing performance by eliminating unnecessary database queries.</li> <li>Several critical bug fixes, improving the stability and reliability of FastCRUD.</li> <li>Documentation enhancements, including the addition of a changelog section, ensuring users have access to detailed release information.</li> <li>Update to FastAPI <code>0.111.0</code>, ensuring compatibility with the latest enhancements in the FastAPI ecosystem.</li> <li>Achievement of 100% test coverage, marking a significant milestone in the project's commitment to reliability and quality assurance.</li> </ul>"},{"location":"changelog/#relevant-contributors","title":"Relevant Contributors","text":"<ul> <li>@dubusster made a notable contribution with the implementation of multiple primary keys support in PR #31.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0100-mar-30-2024","title":"[0.10.0] - Mar 30, 2024","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li><code>select</code> statement functionality, thanks to @dubusster's contribution in PR #28 \ud83d\ude80.</li> <li>Support for joined models in the <code>count</code> method through the <code>joins_config</code> parameter.</li> <li>Filters for joined models via the <code>filters</code> parameter in <code>JoinConfig</code>.</li> <li>Type checking workflow integrated with <code>mypy</code> alongside fixes for typing issues.</li> <li>Linting workflow established with <code>ruff</code>.</li> </ul>"},{"location":"changelog/#detailed-changes_5","title":"Detailed Changes","text":""},{"location":"changelog/#select","title":"Select","text":"<p>The <code>select</code> method constructs a SQL Alchemy <code>Select</code> statement, offering flexibility in column selection, filtering, and sorting. It is designed to chain additional SQLAlchemy methods for complex queries. Docs here and here.</p>"},{"location":"changelog/#features","title":"Features:","text":"<ul> <li>Column Selection: Choose columns via a Pydantic schema.</li> <li>Sorting: Define columns and their order for sorting.</li> <li>Filtering: Directly apply filters through keyword arguments.</li> <li>Chaining: Allow for chaining with other SQLAlchemy methods for advanced query construction.</li> </ul>"},{"location":"changelog/#improved-joins","title":"Improved Joins","text":"<p><code>JoinConfig</code> enhances FastCRUD queries by detailing join operations between models, offering configurations like model joining, conditions, prefixes, column selection through schemas, join types, aliases, and direct filtering. Docs here.</p>"},{"location":"changelog/#applying-joins-in-fastcrud-methods","title":"Applying Joins in FastCRUD Methods","text":"<p>Detailed explanations and examples are provided for using joins in <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code> methods to achieve complex data retrieval, including handling of many-to-many relationships.</p>"},{"location":"changelog/#whats-changed_4","title":"What's Changed","text":"<ul> <li>New <code>select</code> statement functionality added.</li> <li>Documentation and method improvements for select and joins.</li> <li>Integration of type checking and linting workflows.</li> <li>Version bump in pyproject.toml.</li> </ul>"},{"location":"changelog/#new-contributors_2","title":"New Contributors","text":"<ul> <li>@dubusster made their first contribution in PR #28.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#091-mar-19-2024","title":"[0.9.1] - Mar 19, 2024","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Enhanced <code>get_joined</code> and <code>get_multi_joined</code> methods to support aliases, enabling multiple joins on the same model. This improvement addresses issue #27.</li> </ul>"},{"location":"changelog/#detailed-changes_6","title":"Detailed Changes","text":""},{"location":"changelog/#alias-support-for-complex-joins","title":"Alias Support for Complex Joins","text":"<p>With the introduction of alias support, <code>get_joined</code> and <code>get_multi_joined</code> methods now allow for more complex queries, particularly beneficial in scenarios requiring self-joins or multiple joins on the same table. Aliases help to avoid conflicts and ambiguity by providing unique identifiers for the same model in different join contexts. Docs here.</p>"},{"location":"changelog/#example-multiple-joins-with-aliases","title":"Example: Multiple Joins with Aliases","text":"<p>To demonstrate the use of aliases, consider a task management system where tasks are associated with both an owner and an assigned user from the same <code>UserModel</code>. Aliases enable joining the <code>UserModel</code> twice under different contexts - as an owner and an assigned user. This example showcases how to set up aliases using the <code>aliased</code> function and incorporate them into your <code>JoinConfig</code> for clear and conflict-free query construction. Docs here.</p>"},{"location":"changelog/#whats-changed_5","title":"What's Changed","text":"<ul> <li>Introduction of aliases in joins, improving query flexibility and expressiveness, as detailed by @mithun2003 in PR #29.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#090-mar-14-2024","title":"[0.9.0] - Mar 14, 2024","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Enhanced <code>get_joined</code> and <code>get_multi_joined</code> methods now support handling joins with multiple models.</li> </ul>"},{"location":"changelog/#detailed-changes_7","title":"Detailed Changes","text":""},{"location":"changelog/#multi-model-join-capabilities","title":"Multi-Model Join Capabilities","text":"<p>The <code>get_joined</code> and <code>get_multi_joined</code> methods have been upgraded to accommodate joins involving multiple models. This functionality is facilitated through the <code>joins_config</code> parameter, allowing for the specification of multiple <code>JoinConfig</code> instances. Each instance represents a unique join configuration, broadening the scope for complex data relationship management within FastCRUD. Docs here.</p>"},{"location":"changelog/#example-multi-model-join","title":"Example: Multi-Model Join","text":"<p>A practical example involves retrieving users alongside their corresponding tier and department details. By configuring <code>joins_config</code> with appropriate <code>JoinConfig</code> instances for the <code>Tier</code> and <code>Department</code> models, users can efficiently gather comprehensive data across related models, enhancing data retrieval operations' depth and flexibility.</p> <p>Warning</p> <p>An error will occur if both single join parameters and <code>joins_config</code> are used simultaneously. It's crucial to ensure that your join configurations are correctly set to avoid conflicts.</p>"},{"location":"changelog/#whats-changed_6","title":"What's Changed","text":"<ul> <li>Introduction of multi-model join support in <code>get_joined</code> and <code>get_multi_joined</code>, enabling more complex and detailed data retrieval strategies.</li> <li>Several minor updates and fixes, including package import corrections and <code>pyproject.toml</code> updates, to improve the library's usability and stability.</li> </ul>"},{"location":"changelog/#new-contributors_3","title":"New Contributors","text":"<ul> <li>@iridescentGray</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#080-mar-4-2024","title":"[0.8.0] - Mar 4, 2024","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Feature to customize names of auto-generated endpoints using the <code>endpoint_names</code> parameter, applicable in both <code>crud_router</code> function and <code>EndpointCreator</code>.</li> </ul>"},{"location":"changelog/#detailed-changes_8","title":"Detailed Changes","text":""},{"location":"changelog/#custom-endpoint-naming","title":"Custom Endpoint Naming","text":"<p>The introduction of the <code>endpoint_names</code> parameter offers flexibility in defining endpoint names for CRUD operations. This enhancement caters to the need for more descriptive or project-specific naming conventions, enabling developers to align the API's interface with their domain language or organizational standards. </p>"},{"location":"changelog/#example-customizing-endpoint-names-with-crud_router","title":"Example: Customizing Endpoint Names with <code>crud_router</code>","text":"<p>Customizing endpoint names is straightforward with the <code>crud_router</code> function. By providing a dictionary mapping CRUD operation names to desired endpoint names, developers can easily tailor their API's paths to fit their application's unique requirements.</p>"},{"location":"changelog/#example-customizing-endpoint-names-with-endpointcreator","title":"Example: Customizing Endpoint Names with <code>EndpointCreator</code>","text":"<p>Similarly, when using the <code>EndpointCreator</code>, the <code>endpoint_names</code> parameter allows for the same level of customization, ensuring consistency across different parts of the application or service.</p> <p>Tip</p> <p>It's not necessary to specify all endpoint names; only those you wish to change need to be included in the <code>endpoint_names</code> dictionary. This flexibility ensures minimal configuration effort for maximum impact.</p>"},{"location":"changelog/#whats-changed_7","title":"What's Changed","text":"<ul> <li>Enhanced endpoint customization capabilities through <code>endpoint_names</code> parameter, supporting a more tailored and intuitive API design.</li> <li>Documentation updates to guide users through the process of customizing endpoint names.</li> </ul>"},{"location":"changelog/#070-feb-20-2024","title":"[0.7.0] - Feb 20, 2024","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>The <code>get_paginated</code> endpoint for retrieving items with pagination support.</li> <li>The <code>paginated</code> module to offer utility functions for pagination.</li> </ul>"},{"location":"changelog/#detailed-changes_9","title":"Detailed Changes","text":""},{"location":"changelog/#get_paginated-endpoint","title":"<code>get_paginated</code> Endpoint","text":"<p>This new endpoint enhances data retrieval capabilities by introducing pagination, an essential feature for handling large datasets efficiently. It supports customizable query parameters for page number and items per page, facilitating flexible data access patterns. Docs here.</p>"},{"location":"changelog/#features_1","title":"Features:","text":"<ul> <li>Endpoint and Method: A <code>GET</code> request to <code>/get_paginated</code>.</li> <li>Query Parameters: Includes <code>page</code> for the page number and <code>itemsPerPage</code> for controlling the number of items per page.</li> <li>Example Usage: Demonstrated with a request for retrieving items with specified pagination settings.</li> </ul>"},{"location":"changelog/#paginated-module","title":"<code>paginated</code> Module","text":"<p>The introduction of the <code>paginated</code> module brings two key utility functions, <code>paginated_response</code> and <code>compute_offset</code>, which streamline the implementation of paginated responses in the application.</p>"},{"location":"changelog/#functions","title":"Functions:","text":"<ul> <li>paginated_response: Constructs a paginated response based on the input data, page number, and items per page.</li> <li>compute_offset: Calculates the offset for database queries, based on the current page number and the number of items per page.</li> </ul>"},{"location":"changelog/#whats-changed_8","title":"What's Changed","text":"<ul> <li>Deployment of pagination functionality, embodied in the <code>get_paginated</code> endpoint and the <code>paginated</code> module, to facilitate efficient data handling and retrieval.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#060-feb-11-2024","title":"[0.6.0] - Feb 11, 2024","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>The ability to use a custom <code>updated_at</code> column name in models.</li> <li>Making the passing of the <code>crud</code> parameter to <code>crud_router</code> and <code>EndpointCreator</code> optional.</li> <li>Inclusion of exceptions in the <code>http_exceptions</code> module within the broader <code>exceptions</code> module for better organization and accessibility.</li> </ul>"},{"location":"changelog/#detailed-changes_10","title":"Detailed Changes","text":""},{"location":"changelog/#custom-updated_at-column","title":"Custom <code>updated_at</code> Column","text":"<p>FastCRUD now supports the customization of the <code>updated_at</code> column name, providing flexibility for applications with different database schema conventions or naming practices. Docs here.</p>"},{"location":"changelog/#example-configuration","title":"Example Configuration:","text":"<p>The example demonstrates how to specify a custom column name for <code>updated_at</code> when setting up the router for an endpoint, allowing for seamless integration with existing database schemas.</p>"},{"location":"changelog/#whats-changed_9","title":"What's Changed","text":"<ul> <li>Introduction of features enhancing flexibility and usability, such as custom <code>updated_at</code> column names and the optional CRUD parameter in routing configurations.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#050-feb-3-2024","title":"[0.5.0] - Feb 3, 2024","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Advanced filters inspired by Django ORM for enhanced querying capabilities.</li> <li>Optional bulk operations for update and delete methods.</li> <li>Custom soft delete mechanisms integrated into <code>FastCRUD</code>, <code>EndpointCreator</code>, and <code>crud_router</code>.</li> <li>Comprehensive test suite for the newly introduced features.</li> </ul>"},{"location":"changelog/#detailed-changes_11","title":"Detailed Changes","text":""},{"location":"changelog/#advanced-filters","title":"Advanced Filters","text":"<p>The advanced filtering system allows for sophisticated querying with support for operators like <code>__gt</code>, <code>__lt</code>, <code>__gte</code>, and <code>__lte</code>, applicable across various CRUD operations. This feature significantly enhances the flexibility and power of data retrieval and manipulation within FastCRUD. Docs here.</p>"},{"location":"changelog/#examples","title":"Examples:","text":"<ul> <li>Utilization of advanced filters for precise data fetching and aggregation.</li> <li>Implementation examples for fetching records within specific criteria and counting records based on date ranges.</li> </ul>"},{"location":"changelog/#custom-soft-delete-mechanisms","title":"Custom Soft Delete Mechanisms","text":"<p>FastCRUD's soft delete functionality now supports customization, allowing developers to specify alternative column names for <code>is_deleted</code> and <code>deleted_at</code> fields. This adaptation enables seamless integration with existing database schemas that employ different naming conventions for soft deletion tracking. Docs here.</p>"},{"location":"changelog/#example-configuration_1","title":"Example Configuration:","text":"<ul> <li>Setting up <code>crud_router</code> with custom soft delete column names, demonstrating the flexibility in adapting FastCRUD to various database schema requirements.</li> </ul>"},{"location":"changelog/#bulk-operations","title":"Bulk Operations","text":"<p>The introduction of optional bulk operations for updating and deleting records provides a more efficient way to handle large datasets, enabling mass modifications or removals with single method calls. This feature is particularly useful for applications that require frequent bulk data management tasks. Docs here.</p>"},{"location":"changelog/#examples_1","title":"Examples:","text":"<ul> <li>Demonstrating bulk update and delete operations, highlighting the capability to apply changes to multiple records based on specific criteria.</li> </ul>"},{"location":"changelog/#whats-changed_10","title":"What's Changed","text":"<ul> <li>Addition of advanced filters, bulk operations, and custom soft delete functionalities.</li> </ul>"},{"location":"changelog/#new-contributors_4","title":"New Contributors","text":"<ul> <li>@YuriiMotov</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#040-jan-31-2024","title":"[0.4.0] - Jan 31, 2024","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Documentation and tests for SQLModel support.</li> <li><code>py.typed</code> file for better typing support.</li> </ul>"},{"location":"changelog/#detailed","title":"Detailed","text":"<p>Check the docs for SQLModel support.</p>"},{"location":"changelog/#whats-changed_11","title":"What's Changed","text":"<ul> <li>SQLModel support.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#030-jan-28-2024","title":"[0.3.0] - Jan 28, 2024","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>The <code>CustomEndpointCreator</code> for advanced route creation and customization.</li> <li>The ability to selectively include or exclude CRUD operations in the <code>crud_router</code> using <code>included_methods</code> and <code>deleted_methods</code>.</li> <li>Comprehensive tests for the new features.</li> <li>Detailed documentation on utilizing the <code>CustomEndpointCreator</code> and selectively including or excluding endpoints.</li> </ul>"},{"location":"changelog/#customendpointcreator","title":"CustomEndpointCreator","text":"<p>This feature introduces the capability to extend the <code>EndpointCreator</code> class, enabling developers to define custom routes and incorporate complex logic into API endpoints. The documentation has been updated to include detailed examples and guidelines on implementing and using <code>CustomEndpointCreator</code> in projects. Docs here.</p>"},{"location":"changelog/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>The <code>crud_router</code> function has been enhanced with <code>included_methods</code> and <code>deleted_methods</code> parameters, offering developers precise control over which CRUD methods are included or excluded when configuring routers. This addition provides flexibility in API design, allowing for the creation of tailored endpoint setups that meet specific project requirements. Docs here.</p>"},{"location":"changelog/#detailed-changes_12","title":"Detailed Changes","text":""},{"location":"changelog/#extending-endpointcreator","title":"Extending EndpointCreator","text":"<p>Developers can now create a subclass of <code>EndpointCreator</code> to define custom routes or override existing methods, adding a layer of flexibility and customization to FastCRUD's routing capabilities.</p>"},{"location":"changelog/#creating-a-custom-endpointcreator","title":"Creating a Custom EndpointCreator","text":"<p>An example demonstrates how to subclass <code>EndpointCreator</code> and add custom routes or override existing methods, further illustrating how to incorporate custom endpoint logic and route configurations into the FastAPI application.</p>"},{"location":"changelog/#adding-custom-routes","title":"Adding Custom Routes","text":"<p>The process involves overriding the <code>add_routes_to_router</code> method to include both standard CRUD routes and custom routes, showcasing how developers can extend FastCRUD's functionality to suit their application's unique needs.</p>"},{"location":"changelog/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<p>An example highlights how to use the custom <code>EndpointCreator</code> with <code>crud_router</code>, specifying selective methods to be included in the router setup, thereby demonstrating the practical application of custom endpoint creation and selective method inclusion.</p>"},{"location":"changelog/#selective-crud-operations_1","title":"Selective CRUD Operations","text":"<p>Examples for using <code>included_methods</code> and <code>deleted_methods</code> illustrate how to specify exactly which CRUD methods should be included or excluded when setting up the router, offering developers precise control over their API's exposed functionality.</p> <p>Warning</p> <p>Providing both <code>included_methods</code> and <code>deleted_methods</code> will result in a ValueError.</p> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#021-jan-27-2024","title":"[0.2.1] - Jan 27, 2024","text":""},{"location":"changelog/#whats-changed_12","title":"What's Changed","text":"<ul> <li>Improved type hints across the codebase, enhancing the clarity and reliability of type checking within FastCRUD.</li> <li>Documentation has been thoroughly updated and refined, including fixes for previous inaccuracies and the addition of more detailed explanations and examples.</li> <li>Descriptions have been added to automatically generated endpoints, making the API documentation more informative and user-friendly.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#020-jan-25-2024","title":"[0.2.0] - Jan 25, 2024","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Docs Published!</li> </ul>"},{"location":"changelog/#015-jan-24-2024","title":"[0.1.5] - Jan 24, 2024","text":"<p>Readme updates, pyproject requirements</p>"},{"location":"changelog/#012-jan-23-2024","title":"[0.1.2] - Jan 23, 2024","text":"<p>First public release.</p>"},{"location":"installing/","title":"Installing","text":""},{"location":"installing/#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy or SQLModel: FastCRUD uses SQLAlchemy 2.0 for database operations, so you need SQLAlchemy 2.0 or newer or SQLModel 0.14 or newer.</li> <li>Pydantic V2 or SQLModel: FastCRUD leverages Pydantic models for data validation and serialization, so you need Pydantic 2.0 or newer or SQLModel 0.14 or newer.</li> </ul>"},{"location":"installing/#installing","title":"Installing","text":"<p>To install, just run:  <pre><code>pip install fastcrud\n</code></pre></p> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"quick-start/","title":"Quick-Start","text":"<p>If you are using SQLModel, go to Using SQLModel instead.</p>"},{"location":"quick-start/#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your SQLAlchemy model, Pydantic schemas and database connection, just skip to Using FastCRUD</p>"},{"location":"quick-start/#basic-setup","title":"Basic Setup","text":"<p>Define your SQLAlchemy model</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Then your Pydantic schemas</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>And, finally, your database connection</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre>"},{"location":"quick-start/#using-fastcrud","title":"Using FastCRUD","text":"<p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> main.py<pre><code>from fastcrud import crud_router\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"sqlmodel/","title":"Using FastCRUD with SQLModel","text":"<p>Since SQLModel is just a combination of SQLAlchemy and Pydantic, the process simplifies as SQLModel combines the model and schema definitions.</p> <p>Wherever in the docs you see a SQLAlchemy model or Pydantic schema being used, you may just replace it with SQLModel and it will work. For the quick start:</p> <p>Define your SQLModel model</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass Item(SQLModel):\n    __tablename__ = 'items'\n    id: int = Field(primary_key=True)\n    name: str\n\nclass ItemCreateSchema(SQLModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Then your schemas</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass Item(SQLModel):\n    __tablename__ = 'items'\n    id: int = Field(primary_key=True)\n    name: str\n\nclass ItemCreateSchema(SQLModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>And, finally, your database connection</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass Item(SQLModel):\n    __tablename__ = 'items'\n    id: int = Field(primary_key=True)\n    name: str\n\nclass ItemCreateSchema(SQLModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> main.py<pre><code>from fastcrud import crud_router\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>By following the above setup, FastCRUD auto-generates CRUD endpoints for your model, accessible through the <code>/docs</code> route of your FastAPI application.</p>"},{"location":"advanced/crud/","title":"Advanced Use of FastCRUD","text":"<p>FastCRUD offers a flexible and powerful approach to handling CRUD operations in FastAPI applications, leveraging the SQLAlchemy ORM. Beyond basic CRUD functionality, FastCRUD provides advanced features like <code>allow_multiple</code> for updates and deletes, and support for advanced filters (e.g., less than, greater than). These features enable more complex and fine-grained data manipulation and querying capabilities.</p>"},{"location":"advanced/crud/#typing-options-for-fastcrud","title":"Typing Options for <code>FastCRUD</code>","text":"<p>Note that when initializing <code>FastCRUD</code>, assuming you have a model like:</p> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <p>Warning</p> <p>Note that naive <code>datetime</code> such as <code>datetime.utcnow</code> is not supported by <code>FastCRUD</code> as it was deprecated.</p> <p>Use timezone aware <code>datetime</code>, such as <code>datetime.now(UTC)</code> instead.</p> <p>You could just pass it to <code>FastCRUD</code>:</p> <pre><code>from fastcrud import FastCRUD\n\ncrud_user = FastCRUD(User)\n</code></pre> <p>But you also may want a more robust typing, for that purpose, you may also pass the relevant pydantic schemas in the following way:</p> <pre><code>from .models.user import User\nfrom .schemas.user import UserCreate, UserUpdate, UserUpdateInternal, UserDelete\n\n# Just pass None if you don't have one of the schemas\nCRUDUser = FastCRUD[User, UserCreate, UserUpdate, UserUpdateInternal, UserDelete]\n</code></pre> <p>Then you can initialize CRUDUser like you would any FastCRUD instance, but with the relevant types:</p> <pre><code>from .models.user import User\n\ncrud_user = CRUDUser(User)\n</code></pre>"},{"location":"advanced/crud/#allow-multiple-updates-and-deletes","title":"Allow Multiple Updates and Deletes","text":"<p>One of FastCRUD's advanced features is the ability to update or delete multiple records at once based on specified conditions. This is particularly useful for batch operations where you need to modify or remove several records that match certain criteria.</p>"},{"location":"advanced/crud/#updating-multiple-records","title":"Updating Multiple Records","text":"<p>To update multiple records, you can set the <code>allow_multiple=True</code> parameter in the <code>update</code> method. This allows FastCRUD to apply the update to all records matching the given filters.</p> <pre><code># Assuming setup for FastCRUD instance `item_crud` and SQLAlchemy async session `db`\n\n# Update all items priced below $10 to a new price\nawait item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    allow_multiple=True,\n    price__lt=10\n)\n</code></pre>"},{"location":"advanced/crud/#deleting-multiple-records","title":"Deleting Multiple Records","text":"<p>Similarly, you can delete multiple records by using the <code>allow_multiple=True</code> parameter in the <code>delete</code> or <code>db_delete</code> method, depending on whether you're performing a soft or hard delete.</p> <pre><code># Soft delete all items not sold in the last year\nawait item_crud.delete(\n    db=db,\n    allow_multiple=True,\n    last_sold__lt=datetime.datetime.now() - datetime.timedelta(days=365)\n)\n</code></pre>"},{"location":"advanced/crud/#advanced-filters","title":"Advanced Filters","text":"<p>FastCRUD supports advanced filtering options, allowing you to query records using operators such as greater than (<code>__gt</code>), less than (<code>__lt</code>), and their inclusive counterparts (<code>__gte</code>, <code>__lte</code>). These filters can be used in any method that retrieves or operates on records, including <code>get</code>, <code>get_multi</code>, <code>exists</code>, <code>count</code>, <code>update</code>, and <code>delete</code>.</p>"},{"location":"advanced/crud/#using-advanced-filters","title":"Using Advanced Filters","text":"<p>The following examples demonstrate how to use advanced filters for querying and manipulating data:</p>"},{"location":"advanced/crud/#fetching-records-with-advanced-filters","title":"Fetching Records with Advanced Filters","text":"<pre><code># Fetch items priced between $5 and $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__gte=5,\n    price__lte=20\n)\n</code></pre> <p>Currently supported filter operators are: - __gt - greater than - __lt - less than - __gte - greater than or equal to - __lte - less than or equal to - __ne - not equal - __in - included in (tuple, list or set) - __not_in - not included in (tuple, list or set)</p>"},{"location":"advanced/crud/#counting-records","title":"Counting Records","text":"<pre><code># Count items added in the last month\nitem_count = await item_crud.count(\n    db=db,\n    added_at__gte=datetime.datetime.now() - datetime.timedelta(days=30)\n)\n</code></pre>"},{"location":"advanced/crud/#skipping-database-commit","title":"Skipping Database Commit","text":"<p>For <code>create</code>, <code>update</code>, <code>db_delete</code> and <code>delete</code> methods of <code>FastCRUD</code>, you have the option of passing <code>commit=False</code> so you don't commit the operations immediately.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\n\nawait crud_items.delete(\n    db=db, \n    commit=False, \n    id=1\n)\n# this will not actually delete until you run a db.commit()\n</code></pre>"},{"location":"advanced/crud/#unpaginated-get_multi-and-get_multi_joined","title":"Unpaginated <code>get_multi</code> and <code>get_multi_joined</code>","text":"<p>If you pass <code>None</code> to <code>limit</code> in <code>get_multi</code> and <code>get_multi_joined</code>, you get the whole unpaginated set of data that matches the filters. Use this with caution.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nitems = await crud_items.get_multi(db=db, limit=None)\n# this will return all items in the db\n</code></pre> <p>Caution</p> <p>Be cautious when returning all the data in your database, and you should almost never allow your API user to do this.</p>"},{"location":"advanced/crud/#using-get_joined-and-get_multi_joined-for-multiple-models","title":"Using <code>get_joined</code> and <code>get_multi_joined</code> for multiple models","text":"<p>To facilitate complex data relationships, <code>get_joined</code> and <code>get_multi_joined</code> can be configured to handle joins with multiple models. This is achieved using the <code>joins_config</code> parameter, where you can specify a list of <code>JoinConfig</code> instances, each representing a distinct join configuration.</p>"},{"location":"advanced/crud/#example-joining-user-tier-and-department-models","title":"Example: Joining User, Tier, and Department Models","text":"<p>Consider a scenario where you want to retrieve users along with their associated tier and department information. Here's how you can achieve this using <code>get_multi_joined</code>.</p> <p>Start by creating a list of the multiple models to be joined:</p> Join Configurations<pre><code>from fastcrud import JoinConfig\n\njoins_config = [\n    JoinConfig(\n        model=Tier,\n        join_on=User.tier_id == Tier.id,\n        join_prefix=\"tier_\",\n        schema_to_select=TierSchema,\n        join_type=\"left\",\n    ),\n\n    JoinConfig(\n        model=Department,\n        join_on=User.department_id == Department.id,\n        join_prefix=\"dept_\",\n        schema_to_select=DepartmentSchema,\n        join_type=\"inner\",\n    )\n]\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=UserSchema,\n    joins_config=joins_config,\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc'\n)\n</code></pre> <p>Then just pass this list to joins_config:</p> Passing to get_multi_joined<pre><code>from fastcrud import JoinConfig\n\njoins_config = [\n    ...\n]\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=UserSchema,\n    joins_config=joins_config,\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc'\n)\n</code></pre> <p>In this example, users are joined with the <code>Tier</code> and <code>Department</code> models. The <code>join_on</code> parameter specifies the condition for the join, <code>join_prefix</code> assigns a prefix to columns from the joined models (to avoid naming conflicts), and <code>join_type</code> determines whether it's a left or inner join.</p> <p>Warning</p> <p>If both single join parameters and <code>joins_config</code> are used simultaneously, an error will be raised.</p>"},{"location":"advanced/crud/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through its <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>one-to-one</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"advanced/crud/#one-to-one-joins","title":"One-to-One Joins","text":"<p>One-to-one relationships can be efficiently managed using either <code>get_joined</code> or <code>get_multi_joined</code>. The <code>get_joined</code> method is typically used when you want to fetch a single record from the database along with its associated record from another table, such as a user and their corresponding profile details. If you're retrieving multiple records, <code>get_multi_joined</code> can also be used for one-to-one joins. The parameter that deals with it, <code>relationship_type</code>, defaults to <code>one-on-one</code>.</p>"},{"location":"advanced/crud/#one-to-many-joins","title":"One-to-Many Joins","text":"<p>For one-to-many relationships, where a single record can be associated with multiple records in another table, <code>get_joined</code> can be used with <code>nest_joins</code> set to <code>True</code>. This setup allows the primary record to include a nested list of associated records, making it suitable for scenarios such as retrieving a user and all their blog posts. Alternatively, <code>get_multi_joined</code> is also applicable here for fetching multiple primary records, each with their nested lists of related records.</p> <p>Warning</p> <p>When using <code>nested_joins=True</code>, the performance will always be a bit worse than when using <code>nested_joins=False</code>. For cases where more performance is necessary, consider using <code>nested_joins=False</code> and remodeling your database.</p>"},{"location":"advanced/crud/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul>"},{"location":"advanced/crud/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>For a more detailed explanation, you may check the joins docs.</p>"},{"location":"advanced/crud/#using-aliases","title":"Using aliases","text":"<p>In complex query scenarios, particularly when you need to join a table to itself or perform multiple joins on the same table for different purposes, aliasing becomes crucial. Aliasing allows you to refer to the same table in different contexts with unique identifiers, avoiding conflicts and ambiguity in your queries.</p> <p>For both <code>get_joined</code> and <code>get_multi_joined</code> methods, when you need to join the same model multiple times, you can utilize the <code>alias</code> parameter within your <code>JoinConfig</code> to differentiate between the joins. This parameter expects an instance of <code>AliasedClass</code>, which can be created using the <code>aliased</code> function from SQLAlchemy (also in fastcrud for convenience).</p>"},{"location":"advanced/crud/#example-joining-the-same-model-multiple-times","title":"Example: Joining the Same Model Multiple Times","text":"<p>Consider a task management application where tasks have both an owner and an assigned user, represented by the same <code>UserModel</code>. To fetch tasks with details of both users, we use aliases to join the <code>UserModel</code> twice, distinguishing between owners and assigned users.</p> <p>Let's start by creating the aliases and passing them to the join configuration. Don't forget to use the alias for <code>join_on</code>:</p> Join Configurations with Aliases<pre><code>from fastcrud import FastCRUD, JoinConfig, aliased\n\n# Create aliases for UserModel to distinguish between the owner and the assigned user\nowner_alias = aliased(UserModel, name=\"owner\")\nassigned_user_alias = aliased(UserModel, name=\"assigned_user\")\n\n# Configure joins with aliases\njoins_config = [\n    JoinConfig(\n        model=UserModel,\n        join_on=Task.owner_id == owner_alias.id,\n        join_prefix=\"owner_\",\n        schema_to_select=UserSchema,\n        join_type=\"inner\",\n        alias=owner_alias  # Pass the aliased class instance\n    ),\n    JoinConfig(\n        model=UserModel,\n        join_on=Task.assigned_user_id == assigned_user_alias.id,\n        join_prefix=\"assigned_\",\n        schema_to_select=UserSchema,\n        join_type=\"inner\",\n        alias=assigned_user_alias  # Pass the aliased class instance\n    )\n]\n\n# Initialize your FastCRUD instance for TaskModel\ntask_crud = FastCRUD(TaskModel)\n\n# Fetch tasks with joined user details\ntasks = await task_crud.get_multi_joined(\n    db=session,\n    schema_to_select=TaskSchema,\n    joins_config=joins_config,\n    offset=0,\n    limit=10\n)\n</code></pre> <p>Then just pass this joins_config to <code>get_multi_joined</code>:</p> Passing joins_config to get_multi_joined<pre><code>from fastcrud import FastCRUD, JoinConfig, aliased\n\n...\n\n# Configure joins with aliases\njoins_config = [\n    ...\n]\n\n# Initialize your FastCRUD instance for TaskModel\ntask_crud = FastCRUD(TaskModel)\n\n# Fetch tasks with joined user details\ntasks = await task_crud.get_multi_joined(\n    db=session,\n    schema_to_select=TaskSchema,\n    joins_config=joins_config,\n    offset=0,\n    limit=10\n)\n</code></pre> <p>In this example, <code>owner_alias</code> and <code>assigned_user_alias</code> are created from <code>UserModel</code> to distinguish between the task's owner and the assigned user within the task management system. By using aliases, you can join the same model multiple times for different purposes in your queries, enhancing expressiveness and eliminating ambiguity.</p>"},{"location":"advanced/crud/#many-to-many-relationships-with-get_multi_joined","title":"Many-to-Many Relationships with <code>get_multi_joined</code>","text":"<p>FastCRUD simplifies dealing with many-to-many relationships by allowing easy fetch operations with joined models. Here, we demonstrate using <code>get_multi_joined</code> to handle a many-to-many relationship between <code>Project</code> and <code>Participant</code> models, linked through an association table.</p> <p>Note on Handling Many-to-Many Relationships:</p> <p>When using <code>get_multi_joined</code> for many-to-many relationships, it's essential to maintain a specific order in your <code>joins_config</code>: </p> <ol> <li>First, specify the main table you're querying from.</li> <li>Next, include the association table that links your main table to the other table involved in the many-to-many relationship.</li> <li>Finally, specify the other table that is connected via the association table.</li> </ol> <p>This order ensures that the SQL joins are structured correctly to reflect the many-to-many relationship and retrieve the desired data accurately.</p> <p>Tip</p> <p>Note that the first one can be the model defined in <code>FastCRUD(Model)</code>.</p> <pre><code># Fetch projects with their participants via a many-to-many relationship\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n        join_prefix=\"pp_\"\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        join_prefix=\"participant_\"\n    )\n]\n\ncrud_project = FastCRUD(Project)\n\nprojects_with_participants = await project_crud.get_multi_joined(\n    db=db,\n    schema_to_select=ProjectSchema,\n    joins_config=joins_config\n)\n</code></pre> <p>For a more detailed explanation, read this part of the docs.</p>"},{"location":"advanced/crud/#enhanced-query-capabilities-with-method-chaining","title":"Enhanced Query Capabilities with Method Chaining","text":"<p>The <code>select</code> method in FastCRUD is designed for flexibility, enabling you to build complex queries through method chaining.</p>"},{"location":"advanced/crud/#the-select-method","title":"The <code>select</code> Method","text":"<pre><code>async def select(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any\n) -&gt; Selectable\n</code></pre> <p>This method constructs a SQL Alchemy <code>Select</code> statement, offering optional column selection, filtering, and sorting. It's designed for flexibility, allowing you to chain additional SQLAlchemy methods for even more complex queries.</p>"},{"location":"advanced/crud/#features","title":"Features:","text":"<ul> <li>Column Selection: Specify columns with a Pydantic schema.</li> <li>Sorting: Define one or more columns for sorting, along with their sort order.</li> <li>Filtering: Apply filters directly through keyword arguments.</li> <li>Chaining: Chain with other SQLAlchemy methods for advanced query construction.</li> </ul>"},{"location":"advanced/crud/#usage-example","title":"Usage Example:","text":"<pre><code>stmt = await my_model_crud.select(schema_to_select=MySchema, sort_columns='name', name__like='%example%')\nstmt = stmt.where(additional_conditions).limit(10)\nresults = await db.execute(stmt)\n</code></pre> <p>This example demonstrates selecting a subset of columns, applying a filter, and chaining additional conditions like <code>where</code> and <code>limit</code>. Note that <code>select</code> returns a <code>Selectable</code> object, allowing for further modifications before execution.</p>"},{"location":"advanced/crud/#conclusion","title":"Conclusion","text":"<p>The advanced features of FastCRUD, such as <code>allow_multiple</code> and support for advanced filters, empower developers to efficiently manage database records with complex conditions. By leveraging these capabilities, you can build more dynamic, robust, and scalable FastAPI applications that effectively interact with your data model.</p>"},{"location":"advanced/endpoint/","title":"Advanced Use of EndpointCreator","text":""},{"location":"advanced/endpoint/#available-automatic-endpoints","title":"Available Automatic Endpoints","text":"<p>FastCRUD automates the creation of CRUD (Create, Read, Update, Delete) endpoints for your FastAPI application. Here's an overview of the available automatic endpoints and how they work:</p>"},{"location":"advanced/endpoint/#create","title":"Create","text":"<ul> <li>Endpoint: <code>/create</code></li> <li>Method: <code>POST</code></li> <li>Description: Creates a new item in the database.</li> <li>Request Body: JSON object based on the <code>create_schema</code>.</li> <li>Example Request: <code>POST /yourmodel/create</code> with JSON body.</li> </ul>"},{"location":"advanced/endpoint/#read","title":"Read","text":"<ul> <li>Endpoint: <code>/get/{id}</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves a single item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to retrieve.</li> <li>Example Request: <code>GET /yourmodel/get/1</code>.</li> <li>Example Return: <pre><code>{\n    \"id\": 1,\n    \"name\": \"Item 1\",\n    \"description\": \"Description of item 1\"\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#read-multiple","title":"Read Multiple","text":"<ul> <li>Endpoint: <code>/get_multi</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves multiple items with optional pagination.</li> <li>Query Parameters:</li> <li><code>offset</code> (optional): The offset from where to start fetching items.</li> <li><code>limit</code> (optional): The maximum number of items to return.</li> <li>Example Request: <code>GET /yourmodel/get_multi?offset=3&amp;limit=4</code>.</li> <li>Example Return: <pre><code>{\n  \"data\": [\n    {\"id\": 4, \"name\": \"Item 4\", \"description\": \"Description of item 4\"},\n    {\"id\": 5, \"name\": \"Item 5\", \"description\": \"Description of item 5\"},\n    {\"id\": 6, \"name\": \"Item 6\", \"description\": \"Description of item 6\"},\n    {\"id\": 7, \"name\": \"Item 7\", \"description\": \"Description of item 7\"}\n  ],\n  \"total_count\": 50\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#read-paginated","title":"Read Paginated","text":"<ul> <li>Endpoint: <code>/get_paginated</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves multiple items with pagination.</li> <li>Query Parameters:</li> <li><code>page</code>: The page number, starting from 1.</li> <li><code>itemsPerPage</code>: The number of items per page.</li> <li>Example Request: <code>GET /yourmodel/get_paginated?page=1&amp;itemsPerPage=3</code>.</li> <li>Example Return: <pre><code>{\n  \"data\": [\n    {\"id\": 1, \"name\": \"Item 1\", \"description\": \"Description of item 1\"},\n    {\"id\": 2, \"name\": \"Item 2\", \"description\": \"Description of item 2\"},\n    {\"id\": 3, \"name\": \"Item 3\", \"description\": \"Description of item 3\"}\n  ],\n  \"total_count\": 50,\n  \"has_more\": true,\n  \"page\": 1,\n  \"items_per_page\": 3\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#update","title":"Update","text":"<ul> <li>Endpoint: <code>/update/{id}</code></li> <li>Method: <code>PATCH</code></li> <li>Description: Updates an existing item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to update.</li> <li>Request Body: JSON object based on the <code>update_schema</code>.</li> <li>Example Request: <code>PATCH /yourmodel/update/1</code> with JSON body.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#delete","title":"Delete","text":"<ul> <li>Endpoint: <code>/delete/{id}</code></li> <li>Method: <code>DELETE</code></li> <li>Description: Deletes (soft delete if configured) an item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to delete.</li> <li>Example Request: <code>DELETE /yourmodel/delete/1</code>.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#db-delete-hard-delete","title":"DB Delete (Hard Delete)","text":"<ul> <li>Endpoint: <code>/db_delete/{id}</code> (Available if a <code>delete_schema</code> is provided)</li> <li>Method: <code>DELETE</code></li> <li>Description: Permanently deletes an item by its ID, bypassing the soft delete mechanism.</li> <li>Path Parameters: <code>id</code> - The ID of the item to hard delete.</li> <li>Example Request: <code>DELETE /yourmodel/db_delete/1</code>.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>You can control which CRUD operations are exposed by using <code>included_methods</code> and <code>deleted_methods</code>. These parameters allow you to specify exactly which CRUD methods should be included or excluded when setting up the router. By default, all CRUD endpoints are included.</p>"},{"location":"advanced/endpoint/#using-included_methods","title":"Using <code>included_methods</code>","text":"<p>Using <code>included_methods</code> you may define exactly the methods you want to be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"]  # Only these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#using-deleted_methods","title":"Using <code>deleted_methods</code>","text":"<p>Using <code>deleted_methods</code> you define the methods that will not be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    deleted_methods=[\"update\", \"delete\"]  # All but these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre> <p>Warning</p> <pre><code>If `included_methods` and `deleted_methods` are both provided, a ValueError will be raised.\n</code></pre>"},{"location":"advanced/endpoint/#customizing-endpoint-names","title":"Customizing Endpoint Names","text":"<p>You can customize the names of the auto generated endpoints by passing an <code>endpoint_names</code> dictionary when initializing the <code>EndpointCreator</code> or calling the <code>crud_router</code> function. This dictionary should map the CRUD operation names (<code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, <code>db_delete</code>, <code>read_multi</code>, <code>read_paginated</code>) to your desired endpoint names.</p>"},{"location":"advanced/endpoint/#example-using-crud_router","title":"Example: Using <code>crud_router</code>","text":"<p>Here's how you can customize endpoint names using the <code>crud_router</code> function:</p> <pre><code>from fastapi import FastAPI\nfrom yourapp.crud import crud_router\nfrom yourapp.models import YourModel\nfrom yourapp.schemas import CreateYourModelSchema, UpdateYourModelSchema\nfrom yourapp.database import async_session\n\napp = FastAPI()\n\n# Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add\",\n    \"read\": \"fetch\",\n    \"update\": \"modify\",\n    \"delete\": \"remove\",\n    \"read_multi\": \"list\",\n    \"read_paginated\": \"paginate\"\n}\n\n# Setup CRUD router with custom endpoint names\napp.include_router(crud_router(\n    session=async_session,\n    model=YourModel,\n    create_schema=CreateYourModelSchema,\n    update_schema=UpdateYourModelSchema,\n    path=\"/yourmodel\",\n    tags=[\"YourModel\"],\n    endpoint_names=custom_endpoint_names\n))\n</code></pre> <p>In this example, the standard CRUD endpoints will be replaced with <code>/add</code>, <code>/fetch/{id}</code>, <code>/modify/{id}</code>, <code>/remove/{id}</code>, <code>/list</code>, and <code>/paginate</code>.</p>"},{"location":"advanced/endpoint/#example-using-endpointcreator","title":"Example: Using <code>EndpointCreator</code>","text":"<p>If you are using <code>EndpointCreator</code>, you can also pass the <code>endpoint_names</code> dictionary to customize the endpoint names similarly:</p> <pre><code># Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add_new\",\n    \"read\": \"get_single\",\n    \"update\": \"change\",\n    \"delete\": \"erase\",\n    \"db_delete\": \"hard_erase\",\n    \"read_multi\": \"get_all\",\n    \"read_paginated\": \"get_page\"\n}\n\n# Initialize and use the custom EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=YourModel,\n    create_schema=CreateYourModelSchema,\n    update_schema=UpdateYourModelSchema,\n    path=\"/yourmodel\",\n    tags=[\"YourModel\"],\n    endpoint_names=custom_endpoint_names\n)\n\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router)\n</code></pre> <p>Tip</p> <p>You only need to pass the names of the endpoints you want to change in the endpoint_names dict.</p>"},{"location":"advanced/endpoint/#extending-endpointcreator","title":"Extending EndpointCreator","text":"<p>You can create a subclass of <code>EndpointCreator</code> and override or add new methods to define custom routes. Here's an example:</p>"},{"location":"advanced/endpoint/#creating-a-custom-endpointcreator","title":"Creating a Custom EndpointCreator","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#adding-custom-routes","title":"Adding custom routes","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#overriding-add_routes_to_router","title":"Overriding <code>add_routes_to_router</code>","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<pre><code># Assuming MyCustomEndpointCreator was created\n\n...\n\n# Use the custom EndpointCreator with crud_router\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    endpoint_creator=MyCustomEndpointCreator,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"]  # Including selective methods\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#custom-soft-delete","title":"Custom Soft Delete","text":"<p>To implement custom soft delete columns using <code>EndpointCreator</code> and <code>crud_router</code> in FastCRUD, you need to specify the names of the columns used for indicating deletion status and the deletion timestamp in your model. FastCRUD provides flexibility in handling soft deletes by allowing you to configure these column names directly when setting up CRUD operations or API endpoints.</p> <p>Here's how to specify custom soft delete columns when utilizing <code>EndpointCreator</code> and <code>crud_router</code>:</p>"},{"location":"advanced/endpoint/#defining-models-with-custom-soft-delete-columns","title":"Defining Models with Custom Soft Delete Columns","text":"<p>First, ensure your SQLAlchemy model is equipped with the custom soft delete columns. Here's an example model with custom columns for soft deletion:</p> <pre><code>from sqlalchemy import Column, Integer, String, DateTime, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom datetime import datetime\n\nBase = declarative_base()\n\nclass MyModel(Base):\n    __tablename__ = 'my_model'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    archived = Column(Boolean, default=False)  # Custom soft delete column\n    archived_at = Column(DateTime)  # Custom timestamp column for soft delete\n</code></pre>"},{"location":"advanced/endpoint/#using-endpointcreator-and-crud_router-with-custom-soft-delete-or-update-columns","title":"Using <code>EndpointCreator</code> and <code>crud_router</code> with Custom Soft Delete or Update Columns","text":"<p>When initializing <code>crud_router</code> or creating a custom <code>EndpointCreator</code>, you can pass the names of your custom soft delete columns through the <code>FastCRUD</code> initialization. This informs FastCRUD which columns to check and update for soft deletion operations.</p> <p>Here's an example of using <code>crud_router</code> with custom soft delete columns:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\napp = FastAPI()\n\n# Assuming async_session is your AsyncSession generator\n# and MyModel is your SQLAlchemy model\n\n# Initialize FastCRUD with custom soft delete columns\nmy_model_crud = FastCRUD(MyModel,\n                         is_deleted_column='archived',  # Custom 'is_deleted' column name\n                         deleted_at_column='archived_at'  # Custom 'deleted_at' column name\n                        )\n\n# Setup CRUD router with the FastCRUD instance\napp.include_router(crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=my_model_crud,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n))\n</code></pre> <p>You may also directly pass the names of the columns to crud_router or EndpointCreator:</p> <pre><code>app.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    is_deleted_column='archived',\n    deleted_at_column='archived_at'\n))\n</code></pre> <p>You can also customize your <code>updated_at</code> column:</p> <pre><code>app.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    updated_at_column='date_updated'\n))\n</code></pre> <p>This setup ensures that the soft delete functionality within your application utilizes the <code>archived</code> and <code>archived_at</code> columns for marking records as deleted, rather than the default <code>is_deleted</code> and <code>deleted_at</code> fields.</p> <p>By specifying custom column names for soft deletion, you can adapt FastCRUD to fit the design of your database models, providing a flexible solution for handling deleted records in a way that best suits your application's needs.</p>"},{"location":"advanced/endpoint/#using-filters-in-fastcrud","title":"Using Filters in FastCRUD","text":"<p>FastCRUD provides filtering capabilities, allowing you to filter query results based on various conditions. Filters can be applied to <code>read_multi</code> and <code>read_paginated</code> endpoints. This section explains how to configure and use filters in FastCRUD.</p>"},{"location":"advanced/endpoint/#defining-filters","title":"Defining Filters","text":"<p>Filters are either defined using the <code>FilterConfig</code> class or just passed as a dictionary. This class allows you to specify default filter values and validate filter types. Here's an example of how to define filters for a model:</p> <pre><code>from fastcrud import FilterConfig\n\n# Define filter configuration for a model\nfilter_config = FilterConfig(\n    tier_id=None,  # Default filter value for tier_id\n    name=None  # Default filter value for name\n)\n</code></pre> <p>And the same thing using a <code>dict</code>: <pre><code>filter_config = {\n    \"tier_id\": None,  # Default filter value for tier_id\n    \"name\": None,  # Default filter value for name\n}\n</code></pre></p> <p>By using <code>FilterConfig</code> you get better error messages.</p>"},{"location":"advanced/endpoint/#applying-filters-to-endpoints","title":"Applying Filters to Endpoints","text":"<p>You can apply filters to your endpoints by passing the <code>filter_config</code> to the <code>crud_router</code> or <code>EndpointCreator</code>. Here's an example:</p> <pre><code>from fastcrud import crud_router\nfrom yourapp.models import YourModel\nfrom yourapp.schemas import CreateYourModelSchema, UpdateYourModelSchema\nfrom yourapp.database import async_session\n\n# Apply filters using crud_router\napp.include_router(\n    crud_router(\n        session=async_session,\n        model=YourModel,\n        create_schema=CreateYourModelSchema,\n        update_schema=UpdateYourModelSchema,\n        filter_config=filter_config,  # Apply the filter configuration\n        path=\"/yourmodel\",\n        tags=[\"YourModel\"]\n    )\n)\n</code></pre>"},{"location":"advanced/endpoint/#using-filters-in-requests","title":"Using Filters in Requests","text":"<p>Once filters are configured, you can use them in your API requests. Filters are passed as query parameters. Here's an example of how to use filters in a request to a paginated endpoint:</p> <pre><code>GET /yourmodel/get_paginated?page=1&amp;itemsPerPage=3&amp;tier_id=1&amp;name=Alice\n</code></pre>"},{"location":"advanced/endpoint/#custom-filter-validation","title":"Custom Filter Validation","text":"<p>The <code>FilterConfig</code> class includes a validator to check filter types. If an invalid filter type is provided, a <code>ValueError</code> is raised. You can customize the validation logic by extending the <code>FilterConfig</code> class:</p> <pre><code>from fastcrud import FilterConfig\nfrom pydantic import ValidationError\n\nclass CustomFilterConfig(FilterConfig):\n    @field_validator(\"filters\")\n    def check_filter_types(cls, filters: dict[str, Any]) -&gt; dict[str, Any]:\n        for key, value in filters.items():\n            if not isinstance(value, (type(None), str, int, float, bool)):\n                raise ValueError(f\"Invalid default value for '{key}': {value}\")\n        return filters\n\ntry:\n    # Example of invalid filter configuration\n    invalid_filter_config = CustomFilterConfig(invalid_field=[])\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"advanced/endpoint/#handling-invalid-filter-columns","title":"Handling Invalid Filter Columns","text":"<p>FastCRUD ensures that filters are applied only to valid columns in your model. If an invalid filter column is specified, a <code>ValueError</code> is raised:</p> <pre><code>try:\n    # Example of invalid filter column\n    invalid_filter_config = FilterConfig(non_existent_column=None)\nexcept ValueError as e:\n    print(e)  # Output: Invalid filter column 'non_existent_column': not found in model\n</code></pre>"},{"location":"advanced/endpoint/#conclusion","title":"Conclusion","text":"<p>The <code>EndpointCreator</code> class in FastCRUD offers flexibility and control over CRUD operations and custom endpoint creation. By extending this class or using the <code>included_methods</code> and <code>deleted_methods</code> parameters, you can tailor your API's functionality to your specific requirements, ensuring a more customizable and streamlined experience.</p>"},{"location":"advanced/joins/","title":"Comprehensive Guide to Joins in FastCRUD","text":"<p>FastCRUD simplifies CRUD operations while offering capabilities for handling complex data relationships. This guide thoroughly explores the use of <code>JoinConfig</code> for executing join operations in FastCRUD methods such as <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code>, alongside simplified join techniques for straightforward scenarios.</p>"},{"location":"advanced/joins/#understanding-joinconfig","title":"Understanding <code>JoinConfig</code>","text":"<p><code>JoinConfig</code> is a detailed configuration mechanism for specifying joins between models in FastCRUD queries. It contains the following key attributes:</p> <ul> <li><code>model</code>: The SQLAlchemy model to join.</li> <li><code>join_on</code>: The condition defining how the join connects to other models.</li> <li><code>join_prefix</code>: An optional prefix for the joined columns to avoid column name conflicts.</li> <li><code>schema_to_select</code>: An optional Pydantic schema for selecting specific columns from the joined model.</li> <li><code>join_type</code>: The type of join (e.g., \"left\", \"inner\").</li> <li><code>alias</code>: An optional SQLAlchemy <code>AliasedClass</code> for complex scenarios like self-referential joins or multiple joins on the same model.</li> <li><code>filters</code>: An optional dictionary to apply filters directly to the joined model.</li> <li><code>relationship_type</code>: Specifies the relationship type, such as <code>one-to-one</code> or <code>one-to-many</code>. Default is <code>one-to-one</code>.</li> </ul> <p>Tip</p> <p>For <code>many-to-many</code>, you don't need to pass a <code>relationship_type</code>.</p>"},{"location":"advanced/joins/#applying-joins-in-fastcrud-methods","title":"Applying Joins in FastCRUD Methods","text":""},{"location":"advanced/joins/#the-count-method-with-joins","title":"The <code>count</code> Method with Joins","text":"<p>The <code>count</code> method can be enhanced with join operations to perform complex aggregate queries. While <code>count</code> primarily returns the number of records matching a given condition, introducing joins allows for counting records across related models based on specific relationships and conditions.</p>"},{"location":"advanced/joins/#using-joinconfig","title":"Using <code>JoinConfig</code>","text":"<p>For join requirements, the <code>count</code> method can be invoked with join parameters passed as a list of <code>JoinConfig</code> to the <code>joins_config</code> parameter:</p> <pre><code>from fastcrud import JoinConfig\n# Count the number of tasks assigned to users in a specific department\ntask_count = await task_crud.count(\n    db=db,\n    joins_config=[\n        JoinConfig(\n            model=User, \n            join_on=Task.assigned_user_id == User.id\n        ),\n        JoinConfig(\n            model=Department, \n            join_on=User.department_id == Department.id, \n            filters={\"name\": \"Engineering\"}\n        )\n    ]\n)\n</code></pre>"},{"location":"advanced/joins/#fetching-data-with-get_joined-and-get_multi_joined","title":"Fetching Data with <code>get_joined</code> and <code>get_multi_joined</code>","text":"<p>These methods are essential for retrieving records from a primary model while including related data from one or more joined models. They support both simple and complex joining scenarios, including self-referential joins and many-to-many relationships.</p>"},{"location":"advanced/joins/#simple-joins-using-base-parameters","title":"Simple Joins Using Base Parameters","text":"<p>For simpler join requirements, FastCRUD allows specifying join parameters directly:</p> <ul> <li><code>model</code>: The target model to join.</li> <li><code>join_on</code>: The join condition.</li> <li><code>join_type</code>: Specifies the SQL join type.</li> <li><code>join_prefix</code>: Optional prefix for columns from the joined model.</li> <li><code>alias</code>: An optional SQLAlchemy <code>AliasedClass</code> for complex scenarios like self-referential joins or multiple joins on the same model.</li> <li><code>filters</code>: Additional filters for the joined model.</li> </ul>"},{"location":"advanced/joins/#examples-of-simple-joining","title":"Examples of Simple Joining","text":"<pre><code># Fetch tasks with user details, specifying a left join\ntasks_with_users = await task_crud.get_joined(\n    db=db,\n    join_model=User,\n    join_on=Task.user_id == User.id,\n    join_type=\"left\"\n)\n</code></pre>"},{"location":"advanced/joins/#getting-joined-data-nested","title":"Getting Joined Data Nested","text":"<p>Note that by default, <code>FastCRUD</code> joins all the data and returns it in a single dictionary. Let's define two tables: <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre></p> <p>And join them with <code>FastCRUD</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",,\n    id=1\n)\n</code></pre> <p>We'll get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\",\n}\n</code></pre> <p>If you want the joined data in a nested dictionary instead, you may just pass <code>nest_joins=True</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>And you will get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\",\n    },\n}\n</code></pre> <p>This works for both <code>get_joined</code> and <code>get_multi_joined</code>.</p> <p>Warning</p> <p>Note that the final <code>\"_\"</code> in the passed <code>\"tier_\"</code> is stripped.</p>"},{"location":"advanced/joins/#complex-joins-using-joinconfig","title":"Complex Joins Using <code>JoinConfig</code>","text":"<p>When dealing with more complex join conditions, such as multiple joins, self-referential joins, or needing to specify aliases and filters, <code>JoinConfig</code> instances become the norm. They offer granular control over each join's aspects, enabling precise and efficient data retrieval.</p> <p>Example:</p> <pre><code># Fetch users with details from related departments and roles, using aliases for self-referential joins\nfrom fastcrud import aliased\nmanager_alias = aliased(User)\n\nusers = await user_crud.get_multi_joined(\n    db=db,\n    schema_to_select=UserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Department, \n            join_on=User.department_id == Department.id, \n            join_prefix=\"dept_\"\n        ),\n        JoinConfig(\n            model=Role, \n            join_on=User.role_id == Role.id, \n            join_prefix=\"role_\"\n        ),\n        JoinConfig(\n            model=User, \n            alias=manager_alias, \n            join_on=User.manager_id == manager_alias.id, \n            join_prefix=\"manager_\"\n        )\n    ]\n)\n</code></pre>"},{"location":"advanced/joins/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>one-to-one</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"advanced/joins/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul>"},{"location":"advanced/joins/#example","title":"Example","text":"<p>Let's define two tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <p>Fetch a user and their tier:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre>"},{"location":"advanced/joins/#one-to-one-relationship-with-nested-joins","title":"One-to-One Relationship with Nested Joins","text":"<p>To get the joined data in a nested dictionary:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre>"},{"location":"advanced/joins/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>Warning</p> <p>When using <code>nest_joins=True</code>, the performance will always be a bit worse than when using <code>nest_joins=False</code>. For cases where more performance is necessary, consider using <code>nest_joins=False</code> and remodeling your database.</p>"},{"location":"advanced/joins/#example_1","title":"Example","text":"<p>To demonstrate a one-to-many relationship, let's assume <code>User</code> and <code>Post</code> tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary key=True)\n    name = Column(String)\n\nclass Post(Base):\n    __tablename__ = \"post\"\n    id = Column(Integer, primary key=True)\n    user_id = Column(Integer, ForeignKey(\"user.id\"))\n    content = Column(String)\n</code></pre> <p>Fetch a user and all their posts:</p> <pre><code>user_posts = await user_crud.get_joined(\n    db=db,\n    join_model=Post,\n    join_on=User.id == Post.user_id,\n    join_type=\"left\",\n    join_prefix=\"post_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example User\",\n    \"posts\": [\n        {\n            \"id\": 101,\n            \"user_id\": 1,\n            \"content\": \"First post content\"\n        },\n        {\n            \"id\": 102,\n            \"user_id\": 1,\n            \"content\": \"Second post content\"\n        }\n    ]\n}\n</code></pre>"},{"location":"advanced/joins/#many-to-many-relationships-with-get_multi_joined","title":"Many-to-Many Relationships with <code>get_multi_joined</code>","text":"<p>FastCRUD simplifies dealing with many-to-many relationships by allowing easy fetch operations with joined models. Here, we demonstrate using <code>get_multi_joined</code> to handle a many-to-many relationship between <code>Project</code> and <code>Participant</code> models, linked through an association table.</p> <p>Note on Handling Many-to-Many Relationships:</p> <p>When using <code>get_multi_joined</code> for many-to-many relationships, it's essential to maintain a specific order in your <code>joins_config</code>: </p> <ol> <li>First, specify the main table you're querying from.</li> <li>Next, include the association table that links your main table to the other table involved in the many-to-many relationship.</li> <li>Finally, specify the other table that is connected via the association table.</li> </ol> <p>This order ensures that the SQL joins are structured correctly to reflect the many-to-many relationship and retrieve the desired data accurately.</p> <p>Tip</p> <p>Note that the first one can be the model defined in <code>FastCRUD(Model)</code>.</p>"},{"location":"advanced/joins/#scenario","title":"Scenario","text":"<p>Imagine a scenario where projects have multiple participants, and participants can be involved in multiple projects. This many-to-many relationship is facilitated through an association table.</p>"},{"location":"advanced/joins/#models","title":"Models","text":"<p>Our models include <code>Project</code>, <code>Participant</code>, and an association model <code>ProjectsParticipantsAssociation</code>:</p> <pre><code>from sqlalchemy import Column, Integer, String, ForeignKey, Table\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass Project(Base):\n    __tablename__ = 'projects'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    # Relationship to Participant through the association table\n    participants = relationship(\"Participant\", secondary=projects_participants_association)\n\nclass Participant(Base):\n    __tablename__ = 'participants'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    role = Column(String)\n    # Relationship to Project through the association table\n    projects = relationship(\"Project\", secondary=projects_participants_association)\n\n# Association table for the many-to-many relationship\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre>"},{"location":"advanced/joins/#fetching-data-with-get_multi_joined","title":"Fetching Data with <code>get_multi_joined</code>","text":"<p>To fetch projects along with their participants, we utilize <code>get_multi_joined</code> with appropriate <code>JoinConfig</code> settings:</p> <pre><code>from fastcrud import FastCRUD, JoinConfig\n\n# Initialize FastCRUD for the Project model\ncrud_project = FastCRUD(Project)\n\n# Define join conditions and configuration\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n        join_prefix=\"pp_\"\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        join_prefix=\"participant_\"\n    )\n]\n\n# Fetch projects with their participants\nprojects_with_participants = await crud_project.get_multi_joined(\n    db_session, \n    joins_config=joins_config\n)\n\n# Now, `projects_with_participants['data']` will contain projects along with their participant information.\n</code></pre>"},{"location":"advanced/joins/#example_2","title":"Example","text":"<p>Imagine a scenario where projects have multiple participants, and participants can be involved in multiple projects. This many-to-many relationship is facilitated through an association table.</p> <p>Define the models:</p> <pre><code>class Project(Base):\n    __tablename__ = 'projects'\n    id = Column(Integer, primary key=True)\n    name = Column(String)\n    description = Column(String)\n    participants = relationship(\"Participant\", secondary=projects_participants_association)\n\nclass Participant(Base):\n    __tablename__ = 'participants'\n    id = Column(Integer, primary key=True)\n    name = Column(String)\n    role = Column(String)\n    projects = relationship(\"Project\", secondary=projects_participants_association)\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary key=True)\n</code></pre> <p>Fetch projects along with their participants:</p> <pre><code>from fastcrud import FastCRUD, JoinConfig\n\ncrud_project = FastCRUD(Project)\n\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n        join_prefix=\"pp_\"\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        join_prefix=\"participant_\"\n    )\n]\n\nprojects_with_participants = await crud_project.get_multi_joined(\n    db_session, \n    joins_config=joins_config\n)\n</code></pre> <p>The result will be:</p> <pre><code>[\n    {\n        \"id\": 1,\n        \"name\": \"Project A\",\n        \"description\": \"Description of Project A\",\n        \"participants\": [\n            {\n                \"id\": 1,\n                \"name\": \"Participant 1\",\n                \"role\": \"Developer\"\n            },\n            {\n                \"id\": 2,\n                \"name\": \"Participant 2\",\n                \"role\": \"Designer\"\n            }\n        ]\n    },\n    {\n        \"id\": 2,\n        \"name\": \"Project B\",\n        \"description\": \"Description of Project B\",\n        \"participants\": [\n            {\n                \"id\": 3,\n                \"name\": \"Participant 3\",\n                \"role\": \"Manager\"\n            },\n            {\n                \"id\": 4,\n                \"name\": \"Participant 4\",\n                \"role\": \"Tester\"\n            }\n        ]\n    }\n]\n</code></pre>"},{"location":"advanced/joins/#practical-tips-for-advanced-joins","title":"Practical Tips for Advanced Joins","text":"<ul> <li>Prefixing: Always use the <code>join_prefix</code> attribute to avoid column name collisions, especially in complex joins involving multiple models or self-referential joins.</li> <li>Aliasing: Utilize the <code>alias</code> attribute for disambiguating joins on the same model or for self-referential joins.</li> <li>Filtering Joined Models: Apply filters directly to joined models using the <code>filters</code> attribute in <code>JoinConfig</code> to refine the data set returned by the query.</li> <li>Ordering Joins: In many-to-many relationships or complex join scenarios, carefully sequence your <code>JoinConfig</code> entries to ensure logical and efficient SQL join construction.</li> </ul>"},{"location":"advanced/joins/#conclusion","title":"Conclusion","text":"<p>FastCRUD's support for join operations enhances the ability to perform complex queries across related models in FastAPI applications. By understanding and utilizing the <code>JoinConfig</code> class within the <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code> methods, developers can craft powerful data retrieval queries.</p>"},{"location":"advanced/overview/","title":"Advanced Usage Overview","text":"<p>The Advanced section of our documentation delves into the sophisticated capabilities and features of our application, tailored for users looking to leverage advanced functionalities. This part of our guide aims to unlock deeper insights and efficiencies through more complex use cases and configurations.</p>"},{"location":"advanced/overview/#key-topics","title":"Key Topics","text":""},{"location":"advanced/overview/#1-advanced-filtering-and-searching","title":"1. Advanced Filtering and Searching","text":"<p>Explore how to implement advanced filtering and searching capabilities in your application. This guide covers the use of comparison operators (such as greater than, less than, etc.), pattern matching, and more to perform complex queries.</p> <ul> <li>Advanced Filtering Guide</li> </ul>"},{"location":"advanced/overview/#2-bulk-operations-and-batch-processing","title":"2. Bulk Operations and Batch Processing","text":"<p>Learn how to efficiently handle bulk operations and batch processing. This section provides insights into performing mass updates, deletes, and inserts, optimizing performance for large datasets.</p> <ul> <li>Bulk Operations Guide</li> </ul>"},{"location":"advanced/overview/#3-soft-delete-mechanisms-and-strategies","title":"3. Soft Delete Mechanisms and Strategies","text":"<p>Understand the implementation of soft delete mechanisms within our application. This guide covers configuring and using custom columns for soft deletes, restoring deleted records, and filtering queries to exclude soft-deleted entries.</p> <ul> <li>Soft Delete Strategies Guide</li> </ul>"},{"location":"advanced/overview/#4-advanced-use-of-endpointcreator-and-crud_router","title":"4. Advanced Use of EndpointCreator and crud_router","text":"<p>This topic extends the use of <code>EndpointCreator</code> and <code>crud_router</code> for advanced endpoint management, including creating custom routes, selective method exposure, and integrating soft delete functionalities.</p> <ul> <li>Advanced Endpoint Management Guide</li> </ul>"},{"location":"advanced/overview/#5-using-get_joined-and-get_multi_joined-for-multiple-models","title":"5. Using <code>get_joined</code> and <code>get_multi_joined</code> for multiple models","text":"<p>Explore the use of <code>get_joined</code> and <code>get_multi_joined</code> functions for complex queries that involve joining multiple models, including self-joins and scenarios requiring multiple joins on the same model.</p> <ul> <li>Joining Multiple Models Guide</li> </ul>"},{"location":"advanced/overview/#6-method-chaining-with-select","title":"6. Method Chaining with <code>select</code>","text":"<p>FastCRUD's <code>select</code> method introduces method chaining, allowing for the construction of detailed queries with a focus on precision. It simplifies the process of dynamically applying filters, sorting, and conditions, making it easier to manage complex query requirements.</p> <ul> <li>Method Chaining Guide</li> </ul>"},{"location":"advanced/overview/#7-in-depth-explanation-of-joined-methods","title":"7. In depth explanation of Joined methods","text":"<p>Explore different ways of joining models in FastCRUD with examples and tips.</p> <ul> <li>Joining Models</li> </ul>"},{"location":"advanced/overview/#8-filters-in-automatic-endpoints","title":"8. Filters in Automatic Endpoints","text":"<p>Learn how to add query parameters to your <code>get_multi</code> and <code>get_paginated</code> endpoints.</p> <ul> <li>Filters in Endpoints</li> </ul>"},{"location":"advanced/overview/#prerequisites","title":"Prerequisites","text":"<p>Advanced usage assumes a solid understanding of the basic features and functionalities of our application. Knowledge of FastAPI, SQLAlchemy, and Pydantic is highly recommended to fully grasp the concepts discussed.</p>"},{"location":"api/crud_router/","title":"CRUD Router API Reference","text":"<p><code>crud_router</code> is a utility function for creating and configuring a FastAPI router with CRUD endpoints for a given model.</p>"},{"location":"api/crud_router/#function-definition","title":"Function Definition","text":"<p>Creates and configures a FastAPI router with CRUD endpoints for a given model.</p> <p>This utility function streamlines the process of setting up a router for CRUD operations, using a custom <code>EndpointCreator</code> if provided, and managing dependency injections as well as selective method inclusions or exclusions.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Callable</code> <p>The SQLAlchemy async session.</p> required <code>model</code> <code>type[DeclarativeBase]</code> <p>The SQLAlchemy model.</p> required <code>crud</code> <code>Optional[FastCRUD]</code> <p>An optional FastCRUD instance. If not provided, uses FastCRUD(model).</p> <code>None</code> <code>create_schema</code> <code>Type[CreateSchemaType]</code> <p>Pydantic schema for creating an item.</p> required <code>update_schema</code> <code>Type[UpdateSchemaType]</code> <p>Pydantic schema for updating an item.</p> required <code>delete_schema</code> <code>Optional[Type[DeleteSchemaType]]</code> <p>Optional Pydantic schema for deleting an item.</p> <code>None</code> <code>path</code> <code>str</code> <p>Base path for the CRUD endpoints.</p> <code>''</code> <code>tags</code> <code>Optional[list[Union[str, Enum]]]</code> <p>Optional list of tags for grouping endpoints in the documentation.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>True</code> <code>create_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to include. If None, all methods are included.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to exclude.</p> <code>None</code> <code>endpoint_creator</code> <code>Optional[Type[EndpointCreator]]</code> <p>Optional custom class derived from EndpointCreator for advanced customization.</p> <code>None</code> <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".</p> <code>'updated_at'</code> <code>endpoint_names</code> <code>Optional[dict[str, str]]</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and             values are the custom names to use. Unspecified operations will use default names.</p> <code>None</code> <code>filter_config</code> <code>Optional[Union[FilterConfig, dict]]</code> <p>Optional FilterConfig instance or dictionary to configure filters for the <code>read_multi</code> and <code>read_paginated</code> endpoints.</p> <code>None</code> <p>Returns:</p> Type Description <code>APIRouter</code> <p>Configured APIRouter instance with the CRUD endpoints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both 'included_methods' and 'deleted_methods' are provided.</p> <p>Examples:</p> <p>Basic Setup: <pre><code>router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n</code></pre></p> <p>With Custom Dependencies: <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)):\n    # Implement user retrieval logic\n    return ...\n\nrouter = crud_router(\n    session=async_session,\n    model=UserModel,\n    create_schema=CreateUserSchema,\n    update_schema=UpdateUserSchema,\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    path=\"/users\",\n    tags=[\"Users\"]\n)\n</code></pre></p> <p>Adding Delete Endpoints: <pre><code>router = crud_router(\n    session=async_session,\n    model=ProductModel,\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    delete_schema=DeleteProductSchema,\n    path=\"/products\",\n    tags=[\"Products\"]\n)\n</code></pre></p> <p>Customizing Path and Tags: <pre><code>router = crud_router(\n    session=async_session,\n    model=OrderModel,\n    crud=CRUDOrderModel(OrderModel),\n    create_schema=CreateOrderSchema,\n    update_schema=UpdateOrderSchema,\n    path=\"/orders\",\n    tags=[\"Orders\", \"Sales\"]\n)\n</code></pre></p> <p>Integrating Multiple Models: <pre><code>product_router = crud_router(\n    session=async_session,\n    model=ProductModel,\n    crud=CRUDProductModel(ProductModel),\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    path=\"/products\",\n    tags=[\"Inventory\"]\n)\n\ncustomer_router = crud_router(\n    session=async_session,\n    model=CustomerModel,\n    crud=CRUDCustomerModel(CustomerModel),\n    create_schema=CreateCustomerSchema,\n    update_schema=UpdateCustomerSchema,\n    path=\"/customers\",\n    tags=[\"CRM\"]\n)\n</code></pre></p> <p>With Selective CRUD Methods: <pre><code># Only include 'create' and 'read' methods\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=CRUDMyModel(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    included_methods=[\"create\", \"read\"],\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n</code></pre></p> <p>Using a Custom EndpointCreator: <pre><code>class CustomEndpointCreator(EndpointCreator):\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n        async def add_routes_to_router(self, ...):\n            # First, add standard CRUD routes\n            super().add_routes_to_router(...)\n\n            # Now, add custom routes\n            self.router.add_api_route(\n                path=\"/custom\",\n                endpoint=self._custom_route(),\n                methods=[\"GET\"],\n                tags=self.tags,\n                # Other parameters as needed\n            )\n\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=CRUDMyModel(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    endpoint_creator=CustomEndpointCreator,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n\napp.include_router(my_router)\n</code></pre></p> <p>Customizing Endpoint Names: <pre><code>router = crud_router(\n    session=async_session,\n    model=TaskModel,\n    create_schema=CreateTaskSchema,\n    update_schema=UpdateTaskSchema,\n    path=\"/tasks\",\n    tags=[\"Task Management\"],\n    endpoint_names={\n        \"create\": \"add_task\",\n        \"read\": \"get_task\",\n        \"update\": \"modify_task\",\n        \"delete\": \"remove_task\",\n        \"db_delete\": \"permanently_remove_task\",\n        \"read_multi\": \"list_tasks\",\n        \"read_paginated\": \"paginate_tasks\"\n    }\n)\n</code></pre></p> <p>Using FilterConfig with dict: <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\nfrom myapp.models import MyModel\nfrom myapp.schemas import CreateMyModel, UpdateMyModel\nfrom myapp.database import async_session\n\napp = FastAPI()\n\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"})\n)\n# Adds CRUD routes with filtering capabilities\napp.include_router(router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre></p> <p>Using FilterConfig with keyword arguments: <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\nfrom myapp.models import MyModel\nfrom myapp.schemas import CreateMyModel, UpdateMyModel\nfrom myapp.database import async_session\n\napp = FastAPI()\n\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    filter_config=FilterConfig(id=None, name=\"default\")\n)\n# Adds CRUD routes with filtering capabilities\napp.include_router(router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre></p> Source code in <code>fastcrud/endpoint/crud_router.py</code> <pre><code>def crud_router(\n    session: Callable,\n    model: type[DeclarativeBase],\n    create_schema: Type[CreateSchemaType],\n    update_schema: Type[UpdateSchemaType],\n    crud: Optional[FastCRUD] = None,\n    delete_schema: Optional[Type[DeleteSchemaType]] = None,\n    path: str = \"\",\n    tags: Optional[list[Union[str, Enum]]] = None,\n    include_in_schema: bool = True,\n    create_deps: Sequence[Callable] = [],\n    read_deps: Sequence[Callable] = [],\n    read_multi_deps: Sequence[Callable] = [],\n    read_paginated_deps: Sequence[Callable] = [],\n    update_deps: Sequence[Callable] = [],\n    delete_deps: Sequence[Callable] = [],\n    db_delete_deps: Sequence[Callable] = [],\n    included_methods: Optional[list[str]] = None,\n    deleted_methods: Optional[list[str]] = None,\n    endpoint_creator: Optional[Type[EndpointCreator]] = None,\n    is_deleted_column: str = \"is_deleted\",\n    deleted_at_column: str = \"deleted_at\",\n    updated_at_column: str = \"updated_at\",\n    endpoint_names: Optional[dict[str, str]] = None,\n    filter_config: Optional[Union[FilterConfig, dict]] = None,\n) -&gt; APIRouter:\n    \"\"\"\n    Creates and configures a FastAPI router with CRUD endpoints for a given model.\n\n    This utility function streamlines the process of setting up a router for CRUD operations,\n    using a custom `EndpointCreator` if provided, and managing dependency injections as well\n    as selective method inclusions or exclusions.\n\n    Args:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        crud: An optional FastCRUD instance. If not provided, uses FastCRUD(model).\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        path: Base path for the CRUD endpoints.\n        tags: Optional list of tags for grouping endpoints in the documentation.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        create_deps: Optional list of functions to be injected as dependencies for the create endpoint.\n        read_deps: Optional list of functions to be injected as dependencies for the read endpoint.\n        read_multi_deps: Optional list of functions to be injected as dependencies for the read multiple items endpoint.\n        update_deps: Optional list of functions to be injected as dependencies for the update endpoint.\n        delete_deps: Optional list of functions to be injected as dependencies for the delete endpoint.\n        db_delete_deps: Optional list of functions to be injected as dependencies for the hard delete endpoint.\n        included_methods: Optional list of CRUD methods to include. If None, all methods are included.\n        deleted_methods: Optional list of CRUD methods to exclude.\n        endpoint_creator: Optional custom class derived from EndpointCreator for advanced customization.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and\n                        values are the custom names to use. Unspecified operations will use default names.\n        filter_config: Optional FilterConfig instance or dictionary to configure filters for the `read_multi` and `read_paginated` endpoints.\n\n    Returns:\n        Configured APIRouter instance with the CRUD endpoints.\n\n    Raises:\n        ValueError: If both 'included_methods' and 'deleted_methods' are provided.\n\n    Examples:\n        Basic Setup:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n        ```\n\n        With Custom Dependencies:\n        ```python\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            # Implement user retrieval logic\n            return ...\n\n        router = crud_router(\n            session=async_session,\n            model=UserModel,\n            create_schema=CreateUserSchema,\n            update_schema=UpdateUserSchema,\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            path=\"/users\",\n            tags=[\"Users\"]\n        )\n        ```\n\n        Adding Delete Endpoints:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=ProductModel,\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            delete_schema=DeleteProductSchema,\n            path=\"/products\",\n            tags=[\"Products\"]\n        )\n        ```\n\n        Customizing Path and Tags:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=OrderModel,\n            crud=CRUDOrderModel(OrderModel),\n            create_schema=CreateOrderSchema,\n            update_schema=UpdateOrderSchema,\n            path=\"/orders\",\n            tags=[\"Orders\", \"Sales\"]\n        )\n        ```\n\n        Integrating Multiple Models:\n        ```python\n        product_router = crud_router(\n            session=async_session,\n            model=ProductModel,\n            crud=CRUDProductModel(ProductModel),\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            path=\"/products\",\n            tags=[\"Inventory\"]\n        )\n\n        customer_router = crud_router(\n            session=async_session,\n            model=CustomerModel,\n            crud=CRUDCustomerModel(CustomerModel),\n            create_schema=CreateCustomerSchema,\n            update_schema=UpdateCustomerSchema,\n            path=\"/customers\",\n            tags=[\"CRM\"]\n        )\n        ```\n\n        With Selective CRUD Methods:\n        ```python\n        # Only include 'create' and 'read' methods\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            crud=CRUDMyModel(MyModel),\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            included_methods=[\"create\", \"read\"],\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n        ```\n\n        Using a Custom EndpointCreator:\n        ```python\n        class CustomEndpointCreator(EndpointCreator):\n            def _custom_route(self):\n                async def custom_endpoint():\n                    # Custom endpoint logic\n                    return {\"message\": \"Custom route\"}\n\n                return custom_endpoint\n\n                async def add_routes_to_router(self, ...):\n                    # First, add standard CRUD routes\n                    super().add_routes_to_router(...)\n\n                    # Now, add custom routes\n                    self.router.add_api_route(\n                        path=\"/custom\",\n                        endpoint=self._custom_route(),\n                        methods=[\"GET\"],\n                        tags=self.tags,\n                        # Other parameters as needed\n                    )\n\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            crud=CRUDMyModel(MyModel),\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            endpoint_creator=CustomEndpointCreator,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n\n        app.include_router(my_router)\n        ```\n\n        Customizing Endpoint Names:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=TaskModel,\n            create_schema=CreateTaskSchema,\n            update_schema=UpdateTaskSchema,\n            path=\"/tasks\",\n            tags=[\"Task Management\"],\n            endpoint_names={\n                \"create\": \"add_task\",\n                \"read\": \"get_task\",\n                \"update\": \"modify_task\",\n                \"delete\": \"remove_task\",\n                \"db_delete\": \"permanently_remove_task\",\n                \"read_multi\": \"list_tasks\",\n                \"read_paginated\": \"paginate_tasks\"\n            }\n        )\n        ```\n\n        Using FilterConfig with dict:\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import crud_router\n        from myapp.models import MyModel\n        from myapp.schemas import CreateMyModel, UpdateMyModel\n        from myapp.database import async_session\n\n        app = FastAPI()\n\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"})\n        )\n        # Adds CRUD routes with filtering capabilities\n        app.include_router(router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n\n        Using FilterConfig with keyword arguments:\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import crud_router\n        from myapp.models import MyModel\n        from myapp.schemas import CreateMyModel, UpdateMyModel\n        from myapp.database import async_session\n\n        app = FastAPI()\n\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            filter_config=FilterConfig(id=None, name=\"default\")\n        )\n        # Adds CRUD routes with filtering capabilities\n        app.include_router(router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n    \"\"\"\n    crud = crud or FastCRUD(\n        model=model,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n    )\n\n    endpoint_creator_class = endpoint_creator or EndpointCreator\n    endpoint_creator_instance = endpoint_creator_class(\n        session=session,\n        model=model,\n        crud=crud,\n        create_schema=create_schema,\n        update_schema=update_schema,\n        include_in_schema=include_in_schema,\n        delete_schema=delete_schema,\n        path=path,\n        tags=tags,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n        endpoint_names=endpoint_names,\n        filter_config=filter_config,\n    )\n\n    endpoint_creator_instance.add_routes_to_router(\n        create_deps=create_deps,\n        read_deps=read_deps,\n        read_multi_deps=read_multi_deps,\n        read_paginated_deps=read_paginated_deps,\n        update_deps=update_deps,\n        delete_deps=delete_deps,\n        db_delete_deps=db_delete_deps,\n        included_methods=included_methods,\n        deleted_methods=deleted_methods,\n    )\n\n    return endpoint_creator_instance.router\n</code></pre>"},{"location":"api/endpoint_creator/","title":"EndpointCreator API Reference","text":"<p><code>EndpointCreator</code> is a class designed to create and register CRUD endpoints for a FastAPI application. It simplifies the process of adding CRUD (Create, Read, Update, Delete) endpoints to a FastAPI router.</p>"},{"location":"api/endpoint_creator/#class-definition","title":"Class Definition","text":"<p>A class to create and register CRUD endpoints for a FastAPI application.</p> <p>This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations, and Pydantic schemas, and allows for custom dependency injection for each endpoint. The method assumes 'id' is the primary key for path parameters.</p> <p>Attributes:</p> Name Type Description <code>session</code> <p>The SQLAlchemy async session.</p> <code>model</code> <p>The SQLAlchemy model.</p> <code>crud</code> <p>An optional FastCRUD instance. If not provided, uses FastCRUD(model).</p> <code>create_schema</code> <p>Pydantic schema for creating an item.</p> <code>update_schema</code> <p>Pydantic schema for updating an item.</p> <code>delete_schema</code> <p>Optional Pydantic schema for deleting an item.</p> <code>include_in_schema</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>path</code> <p>Base path for the CRUD endpoints.</p> <code>tags</code> <p>List of tags for grouping endpoints in the documentation.</p> <code>is_deleted_column</code> <p>Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".</p> <code>deleted_at_column</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".</p> <code>updated_at_column</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".</p> <code>endpoint_names</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and             values are the custom names to use. Unspecified operations will use default names.</p> <code>filter_config</code> <p>Optional FilterConfig instance or dictionary to configure filters for the <code>read_multi</code> and <code>read_paginated</code> endpoints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Basic Setup: <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator\n\nfrom myapp.models import MyModel\nfrom myapp.schemas import CreateMyModel, UpdateMyModel\nfrom myapp.database import async_session\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel\n)\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n</code></pre></p> <p>With Custom Dependencies: <pre><code>from fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    return ...\n\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user]\n)\n</code></pre></p> <p>Selective Endpoint Creation (inclusion): <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"]\n)\n</code></pre></p> <p>Selective Endpoint Creation (deletion): <pre><code># Create all but 'update' and 'delete' endpoints\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"update\", \"delete\"]\n)\n</code></pre></p> <p>Integrating with Multiple Models: <pre><code># Assuming definitions for OtherModel, CRUDOtherModel, etc.\n\nother_model_crud = CRUDOtherModel(OtherModel)\nother_endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=OtherModel,\n    crud=other_model_crud,\n    create_schema=CreateOtherModel,\n    update_schema=UpdateOtherModel\n)\nother_endpoint_creator.add_routes_to_router()\napp.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n</code></pre></p> <p>Customizing Endpoint Names: <pre><code>endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names={\n        \"create\": \"add\",  # Custom endpoint name for creating items\n        \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n        \"update\": \"change\",  # Custom endpoint name for updating items\n        # The delete operation will use the default name \"delete\"\n    }\n)\nendpoint_creator.add_routes_to_router()\n</code></pre></p> <p>Using filter_config with dict: <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator, FilterConfig\n\nfrom myapp.models import MyModel\nfrom myapp.schemas import CreateMyModel, UpdateMyModel\nfrom myapp.database import async_session\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"})\n)\n# Adds CRUD routes with filtering capabilities\nendpoint_creator.add_routes_to_router()\n# Include the internal router into the FastAPI app\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre></p> <p>Using filter_config with keyword arguments: <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator, FilterConfig\n\nfrom myapp.models import MyModel\nfrom myapp.schemas: CreateMyModel, UpdateMyModel\nfrom myapp.database: async_session\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    filter_config=FilterConfig(id=None, name=\"default\")\n)\n# Adds CRUD routes with filtering capabilities\nendpoint_creator.add_routes_to_router()\n# Include the internal router into the FastAPI app\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre></p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>class EndpointCreator:\n    \"\"\"\n    A class to create and register CRUD endpoints for a FastAPI application.\n\n    This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints\n    to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations,\n    and Pydantic schemas, and allows for custom dependency injection for each endpoint.\n    The method assumes 'id' is the primary key for path parameters.\n\n    Attributes:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        crud: An optional FastCRUD instance. If not provided, uses FastCRUD(model).\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        path: Base path for the CRUD endpoints.\n        tags: List of tags for grouping endpoints in the documentation.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and\n                        values are the custom names to use. Unspecified operations will use default names.\n        filter_config: Optional FilterConfig instance or dictionary to configure filters for the `read_multi` and `read_paginated` endpoints.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Basic Setup:\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator\n\n        from myapp.models import MyModel\n        from myapp.schemas import CreateMyModel, UpdateMyModel\n        from myapp.database import async_session\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel\n        )\n        endpoint_creator.add_routes_to_router()\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n        ```\n\n        With Custom Dependencies:\n        ```python\n        from fastapi.security import OAuth2PasswordBearer\n\n        oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            return ...\n\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user]\n        )\n        ```\n\n        Selective Endpoint Creation (inclusion):\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"]\n        )\n        ```\n\n        Selective Endpoint Creation (deletion):\n        ```python\n        # Create all but 'update' and 'delete' endpoints\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"update\", \"delete\"]\n        )\n        ```\n\n        Integrating with Multiple Models:\n        ```python\n        # Assuming definitions for OtherModel, CRUDOtherModel, etc.\n\n        other_model_crud = CRUDOtherModel(OtherModel)\n        other_endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=OtherModel,\n            crud=other_model_crud,\n            create_schema=CreateOtherModel,\n            update_schema=UpdateOtherModel\n        )\n        other_endpoint_creator.add_routes_to_router()\n        app.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n        ```\n\n        Customizing Endpoint Names:\n        ```python\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            endpoint_names={\n                \"create\": \"add\",  # Custom endpoint name for creating items\n                \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n                \"update\": \"change\",  # Custom endpoint name for updating items\n                # The delete operation will use the default name \"delete\"\n            }\n        )\n        endpoint_creator.add_routes_to_router()\n        ```\n\n        Using filter_config with dict:\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator, FilterConfig\n\n        from myapp.models import MyModel\n        from myapp.schemas import CreateMyModel, UpdateMyModel\n        from myapp.database import async_session\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"})\n        )\n        # Adds CRUD routes with filtering capabilities\n        endpoint_creator.add_routes_to_router()\n        # Include the internal router into the FastAPI app\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n\n        Using filter_config with keyword arguments:\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator, FilterConfig\n\n        from myapp.models import MyModel\n        from myapp.schemas: CreateMyModel, UpdateMyModel\n        from myapp.database: async_session\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            filter_config=FilterConfig(id=None, name=\"default\")\n        )\n        # Adds CRUD routes with filtering capabilities\n        endpoint_creator.add_routes_to_router()\n        # Include the internal router into the FastAPI app\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        session: Callable,\n        model: type[DeclarativeBase],\n        create_schema: Type[CreateSchemaType],\n        update_schema: Type[UpdateSchemaType],\n        crud: Optional[FastCRUD] = None,\n        include_in_schema: bool = True,\n        delete_schema: Optional[Type[DeleteSchemaType]] = None,\n        path: str = \"\",\n        tags: Optional[list[Union[str, Enum]]] = None,\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n        endpoint_names: Optional[dict[str, str]] = None,\n        filter_config: Optional[Union[FilterConfig, dict]] = None,\n    ) -&gt; None:\n        self._primary_keys = _get_primary_keys(model)\n        self._primary_keys_types = {\n            pk.name: _get_python_type(pk) for pk in self._primary_keys\n        }\n        self.primary_key_names = [pk.name for pk in self._primary_keys]\n        self.session = session\n        self.crud = crud or FastCRUD(\n            model=model,\n            is_deleted_column=is_deleted_column,\n            deleted_at_column=deleted_at_column,\n            updated_at_column=updated_at_column,\n        )\n        self.model = model\n        self.create_schema = create_schema\n        self.update_schema = update_schema\n        self.delete_schema = delete_schema\n        self.include_in_schema = include_in_schema\n        self.path = path\n        self.tags = tags or []\n        self.router = APIRouter()\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n        self.default_endpoint_names = {\n            \"create\": \"create\",\n            \"read\": \"get\",\n            \"update\": \"update\",\n            \"delete\": \"delete\",\n            \"db_delete\": \"db_delete\",\n            \"read_multi\": \"get_multi\",\n            \"read_paginated\": \"get_paginated\",\n        }\n        self.endpoint_names = {**self.default_endpoint_names, **(endpoint_names or {})}\n        if filter_config:\n            if isinstance(filter_config, dict):\n                filter_config = FilterConfig(**filter_config)\n            self._validate_filter_config(filter_config)\n        self.filter_config = filter_config\n        self.column_types = _get_column_types(model)\n\n    def _validate_filter_config(self, filter_config: FilterConfig) -&gt; None:\n        model_columns = self.crud.model_col_names\n        for key in filter_config.filters.keys():\n            if key not in model_columns:\n                raise ValueError(\n                    f\"Invalid filter column '{key}': not found in model '{self.model.__name__}' columns\"\n                )\n\n    def _create_item(self):\n        \"\"\"Creates an endpoint for creating items in the database.\"\"\"\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            item: self.create_schema = Body(...),  # type: ignore\n        ):\n            unique_columns = _extract_unique_columns(self.model)\n\n            for column in unique_columns:\n                col_name = column.name\n                if hasattr(item, col_name):\n                    value = getattr(item, col_name)\n                    exists = await self.crud.exists(db, **{col_name: value})\n                    if exists:  # pragma: no cover\n                        raise DuplicateValueException(\n                            f\"Value {value} is already registered\"\n                        )\n\n            return await self.crud.create(db, item)\n\n        return endpoint\n\n    def _read_item(self):\n        \"\"\"Creates an endpoint for reading a single item from the database.\"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            item = await self.crud.get(db, **pkeys)\n            if not item:  # pragma: no cover\n                raise NotFoundException(detail=\"Item not found\")\n            return item  # pragma: no cover\n\n        return endpoint\n\n    def _read_items(self):\n        \"\"\"Creates an endpoint for reading multiple items from the database.\"\"\"\n        dynamic_filters = _create_dynamic_filters(self.filter_config, self.column_types)\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            offset: int = Query(0),\n            limit: int = Query(100),\n            filters: dict = Depends(dynamic_filters),\n        ):\n            return await self.crud.get_multi(db, offset=offset, limit=limit, **filters)\n\n        return endpoint\n\n    def _read_paginated(self):\n        \"\"\"Creates an endpoint for reading multiple items from the database with pagination.\"\"\"\n        dynamic_filters = _create_dynamic_filters(self.filter_config, self.column_types)\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            page: int = Query(\n                1, alias=\"page\", description=\"Page number, starting from 1\"\n            ),\n            items_per_page: int = Query(\n                10, alias=\"itemsPerPage\", description=\"Number of items per page\"\n            ),\n            filters: dict = Depends(dynamic_filters),\n        ):\n            offset = compute_offset(page=page, items_per_page=items_per_page)\n            crud_data = await self.crud.get_multi(\n                db, offset=offset, limit=items_per_page, **filters\n            )\n\n            return paginated_response(\n                crud_data=crud_data, page=page, items_per_page=items_per_page\n            )  # pragma: no cover\n\n        return endpoint\n\n    def _update_item(self):\n        \"\"\"Creates an endpoint for updating an existing item in the database.\"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(\n            item: self.update_schema = Body(...),  # type: ignore\n            db: AsyncSession = Depends(self.session),\n            **pkeys,\n        ):\n            return await self.crud.update(db, item, **pkeys)\n\n        return endpoint\n\n    def _delete_item(self):\n        \"\"\"Creates an endpoint for deleting an item from the database.\"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            await self.crud.delete(db, **pkeys)\n            return {\"message\": \"Item deleted successfully\"}  # pragma: no cover\n\n        return endpoint\n\n    def _db_delete(self):\n        \"\"\"\n        Creates an endpoint for hard deleting an item from the database.\n\n        This endpoint is only added if the delete_schema is provided during initialization.\n        The endpoint expects an item ID as a path parameter and uses the provided SQLAlchemy\n        async session to permanently delete the item from the database.\n        \"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            await self.crud.db_delete(db, **pkeys)\n            return {\n                \"message\": \"Item permanently deleted from the database\"\n            }  # pragma: no cover\n\n        return endpoint\n\n    def _get_endpoint_name(self, operation: str) -&gt; str:\n        \"\"\"Get the endpoint name for a given CRUD operation, using defaults if not overridden by the user.\"\"\"\n        return self.endpoint_names.get(\n            operation, self.default_endpoint_names.get(operation, operation)\n        )\n\n    def add_routes_to_router(\n        self,\n        create_deps: Sequence[Callable] = [],\n        read_deps: Sequence[Callable] = [],\n        read_multi_deps: Sequence[Callable] = [],\n        read_paginated_deps: Sequence[Callable] = [],\n        update_deps: Sequence[Callable] = [],\n        delete_deps: Sequence[Callable] = [],\n        db_delete_deps: Sequence[Callable] = [],\n        included_methods: Optional[Sequence[str]] = None,\n        deleted_methods: Optional[Sequence[str]] = None,\n    ):\n        \"\"\"\n        Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n        This method registers routes for create, read, update, and delete operations with the FastAPI router,\n        allowing for custom dependency injection for each type of operation.\n\n        Args:\n            create_deps: List of functions to be injected as dependencies for the create endpoint.\n            read_deps: List of functions to be injected as dependencies for the read endpoint.\n            read_multi_deps: List of functions to be injected as dependencies for the read multiple items endpoint.\n            update_deps: List of functions to be injected as dependencies for the update endpoint.\n            delete_deps: List of functions to be injected as dependencies for the delete endpoint.\n            db_delete_deps: List of functions to be injected as dependencies for the hard delete endpoint.\n            included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n            deleted_methods: Optional list of methods to exclude. Defaults to None.\n\n        Raises:\n            ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n        Examples:\n            Selective Endpoint Creation:\n            ```python\n            # Only create 'create' and 'read' endpoints\n            endpoint_creator.add_routes_to_router(\n                included_methods=[\"create\", \"read\"]\n            )\n            ```\n\n            Excluding Specific Endpoints:\n            ```python\n            # Create all endpoints except 'delete' and 'db_delete'\n            endpoint_creator.add_routes_to_router(\n                deleted_methods=[\"delete\", \"db_delete\"]\n            )\n            ```\n\n            With Custom Dependencies and Selective Endpoints:\n            ```python\n            def get_current_user(...):\n                ...\n\n            # Create only 'read' and 'update' endpoints with custom dependencies\n            endpoint_creator.add_routes_to_router(\n                read_deps=[get_current_user],\n                update_deps=[get_current_user],\n                included_methods=[\"read\", \"update\"]\n            )\n            ```\n\n        Note:\n            This method should be called to register the endpoints with the FastAPI application.\n            If 'delete_schema' is provided, a hard delete endpoint is also registered.\n            This method assumes 'id' is the primary key for path parameters.\n        \"\"\"\n        if (included_methods is not None) and (deleted_methods is not None):\n            raise ValueError(\n                \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n            )\n\n        if included_methods is None:\n            included_methods = [\n                \"create\",\n                \"read\",\n                \"read_multi\",\n                \"read_paginated\",\n                \"update\",\n                \"delete\",\n                \"db_delete\",\n            ]\n        else:\n            try:\n                included_methods = CRUDMethods(\n                    valid_methods=included_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n        if deleted_methods is None:\n            deleted_methods = []\n        else:\n            try:\n                deleted_methods = CRUDMethods(\n                    valid_methods=deleted_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n        delete_description = \"Delete a\"\n        if self.delete_schema:\n            delete_description = \"Soft delete a\"\n\n        _primary_keys_path_suffix = \"/\".join(f\"{{{n}}}\" for n in self.primary_key_names)\n\n        if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"create\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}\",\n                self._create_item(),\n                methods=[\"POST\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(create_deps),\n                description=f\"Create a new {self.model.__name__} row in the database.\",\n            )\n\n        if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"read\")\n\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n                self._read_item(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(read_deps),\n                description=f\"Read a single {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"read_multi\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}\",\n                self._read_items(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(read_multi_deps),\n                description=f\"Read multiple {self.model.__name__} rows from the database with a limit and an offset.\",\n            )\n\n        if (\"read_paginated\" in included_methods) and (\n            \"read_paginated\" not in deleted_methods\n        ):\n            endpoint_name = self._get_endpoint_name(\"read_paginated\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}\",\n                self._read_paginated(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(read_paginated_deps),\n                description=f\"Read multiple {self.model.__name__} rows from the database with pagination.\",\n            )\n\n        if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"update\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n                self._update_item(),\n                methods=[\"PATCH\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(update_deps),\n                description=f\"Update an existing {self.model.__name__} row in the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"delete\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n                self._delete_item(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(delete_deps),\n                description=f\"{delete_description} {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\n            (\"db_delete\" in included_methods)\n            and (\"db_delete\" not in deleted_methods)\n            and self.delete_schema\n        ):\n            endpoint_name = self._get_endpoint_name(\"db_delete\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n                self._db_delete(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(db_delete_deps),\n                description=f\"Permanently delete a {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n    def add_custom_route(\n        self,\n        endpoint: Callable,\n        methods: Optional[Union[set[str], list[str]]],\n        path: Optional[str] = None,\n        dependencies: Optional[Sequence[Callable]] = None,\n        include_in_schema: bool = True,\n        tags: Optional[list[Union[str, Enum]]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n    ) -&gt; None:\n        \"\"\"\n        Adds a custom route to the FastAPI router.\n\n        Args:\n            path: URL path for the custom route.\n            endpoint: The endpoint function to execute when the route is called.\n            methods: A list of HTTP methods for the route (e.g., ['GET', 'POST']).\n            dependencies: A list of functions to be injected as dependencies for the route.\n            include_in_schema: Whether to include this route in the OpenAPI schema.\n            tags: Tags for grouping and categorizing the route in documentation.\n            summary: A short summary of the route, for documentation.\n            description: A detailed description of the route, for documentation.\n            response_description: A description of the response, for documentation.\n\n        Example:\n            ```python\n            async def custom_endpoint(foo: int, bar: str):\n                # custom logic here\n                return {\"foo\": foo, \"bar\": bar}\n\n            endpoint_creator.add_custom_route(\n                endpoint=custom_endpoint,\n                path=\"/custom\",\n                methods=[\"GET\"],\n                tags=[\"custom\"],\n                summary=\"Custom Endpoint\",\n                description=\"This is a custom endpoint.\"\n            )\n            ```\n        \"\"\"\n        path = path or self.path\n        full_path = f\"{self.path}{path}\"\n        self.router.add_api_route(\n            path=full_path,\n            endpoint=endpoint,\n            methods=methods,\n            dependencies=_inject_dependencies(dependencies) or [],\n            include_in_schema=include_in_schema,\n            tags=tags or self.tags,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n        )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_custom_route","title":"<code>add_custom_route(endpoint, methods, path=None, dependencies=None, include_in_schema=True, tags=None, summary=None, description=None, response_description='Successful Response')</code>","text":"<p>Adds a custom route to the FastAPI router.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[str]</code> <p>URL path for the custom route.</p> <code>None</code> <code>endpoint</code> <code>Callable</code> <p>The endpoint function to execute when the route is called.</p> required <code>methods</code> <code>Optional[Union[set[str], list[str]]]</code> <p>A list of HTTP methods for the route (e.g., ['GET', 'POST']).</p> required <code>dependencies</code> <code>Optional[Sequence[Callable]]</code> <p>A list of functions to be injected as dependencies for the route.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include this route in the OpenAPI schema.</p> <code>True</code> <code>tags</code> <code>Optional[list[Union[str, Enum]]]</code> <p>Tags for grouping and categorizing the route in documentation.</p> <code>None</code> <code>summary</code> <code>Optional[str]</code> <p>A short summary of the route, for documentation.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A detailed description of the route, for documentation.</p> <code>None</code> <code>response_description</code> <code>str</code> <p>A description of the response, for documentation.</p> <code>'Successful Response'</code> Example <pre><code>async def custom_endpoint(foo: int, bar: str):\n    # custom logic here\n    return {\"foo\": foo, \"bar\": bar}\n\nendpoint_creator.add_custom_route(\n    endpoint=custom_endpoint,\n    path=\"/custom\",\n    methods=[\"GET\"],\n    tags=[\"custom\"],\n    summary=\"Custom Endpoint\",\n    description=\"This is a custom endpoint.\"\n)\n</code></pre> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_custom_route(\n    self,\n    endpoint: Callable,\n    methods: Optional[Union[set[str], list[str]]],\n    path: Optional[str] = None,\n    dependencies: Optional[Sequence[Callable]] = None,\n    include_in_schema: bool = True,\n    tags: Optional[list[Union[str, Enum]]] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    response_description: str = \"Successful Response\",\n) -&gt; None:\n    \"\"\"\n    Adds a custom route to the FastAPI router.\n\n    Args:\n        path: URL path for the custom route.\n        endpoint: The endpoint function to execute when the route is called.\n        methods: A list of HTTP methods for the route (e.g., ['GET', 'POST']).\n        dependencies: A list of functions to be injected as dependencies for the route.\n        include_in_schema: Whether to include this route in the OpenAPI schema.\n        tags: Tags for grouping and categorizing the route in documentation.\n        summary: A short summary of the route, for documentation.\n        description: A detailed description of the route, for documentation.\n        response_description: A description of the response, for documentation.\n\n    Example:\n        ```python\n        async def custom_endpoint(foo: int, bar: str):\n            # custom logic here\n            return {\"foo\": foo, \"bar\": bar}\n\n        endpoint_creator.add_custom_route(\n            endpoint=custom_endpoint,\n            path=\"/custom\",\n            methods=[\"GET\"],\n            tags=[\"custom\"],\n            summary=\"Custom Endpoint\",\n            description=\"This is a custom endpoint.\"\n        )\n        ```\n    \"\"\"\n    path = path or self.path\n    full_path = f\"{self.path}{path}\"\n    self.router.add_api_route(\n        path=full_path,\n        endpoint=endpoint,\n        methods=methods,\n        dependencies=_inject_dependencies(dependencies) or [],\n        include_in_schema=include_in_schema,\n        tags=tags or self.tags,\n        summary=summary,\n        description=description,\n        response_description=response_description,\n    )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_routes_to_router","title":"<code>add_routes_to_router(create_deps=[], read_deps=[], read_multi_deps=[], read_paginated_deps=[], update_deps=[], delete_deps=[], db_delete_deps=[], included_methods=None, deleted_methods=None)</code>","text":"<p>Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.</p> <p>This method registers routes for create, read, update, and delete operations with the FastAPI router, allowing for custom dependency injection for each type of operation.</p> <p>Parameters:</p> Name Type Description Default <code>create_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[Sequence[str]]</code> <p>Optional list of methods to include. Defaults to all CRUD methods.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[Sequence[str]]</code> <p>Optional list of methods to exclude. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Selective Endpoint Creation: <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"]\n)\n</code></pre></p> <p>Excluding Specific Endpoints: <pre><code># Create all endpoints except 'delete' and 'db_delete'\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"delete\", \"db_delete\"]\n)\n</code></pre></p> <p>With Custom Dependencies and Selective Endpoints: <pre><code>def get_current_user(...):\n    ...\n\n# Create only 'read' and 'update' endpoints with custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    included_methods=[\"read\", \"update\"]\n)\n</code></pre></p> Note <p>This method should be called to register the endpoints with the FastAPI application. If 'delete_schema' is provided, a hard delete endpoint is also registered. This method assumes 'id' is the primary key for path parameters.</p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_routes_to_router(\n    self,\n    create_deps: Sequence[Callable] = [],\n    read_deps: Sequence[Callable] = [],\n    read_multi_deps: Sequence[Callable] = [],\n    read_paginated_deps: Sequence[Callable] = [],\n    update_deps: Sequence[Callable] = [],\n    delete_deps: Sequence[Callable] = [],\n    db_delete_deps: Sequence[Callable] = [],\n    included_methods: Optional[Sequence[str]] = None,\n    deleted_methods: Optional[Sequence[str]] = None,\n):\n    \"\"\"\n    Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n    This method registers routes for create, read, update, and delete operations with the FastAPI router,\n    allowing for custom dependency injection for each type of operation.\n\n    Args:\n        create_deps: List of functions to be injected as dependencies for the create endpoint.\n        read_deps: List of functions to be injected as dependencies for the read endpoint.\n        read_multi_deps: List of functions to be injected as dependencies for the read multiple items endpoint.\n        update_deps: List of functions to be injected as dependencies for the update endpoint.\n        delete_deps: List of functions to be injected as dependencies for the delete endpoint.\n        db_delete_deps: List of functions to be injected as dependencies for the hard delete endpoint.\n        included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n        deleted_methods: Optional list of methods to exclude. Defaults to None.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Selective Endpoint Creation:\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"]\n        )\n        ```\n\n        Excluding Specific Endpoints:\n        ```python\n        # Create all endpoints except 'delete' and 'db_delete'\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"delete\", \"db_delete\"]\n        )\n        ```\n\n        With Custom Dependencies and Selective Endpoints:\n        ```python\n        def get_current_user(...):\n            ...\n\n        # Create only 'read' and 'update' endpoints with custom dependencies\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            included_methods=[\"read\", \"update\"]\n        )\n        ```\n\n    Note:\n        This method should be called to register the endpoints with the FastAPI application.\n        If 'delete_schema' is provided, a hard delete endpoint is also registered.\n        This method assumes 'id' is the primary key for path parameters.\n    \"\"\"\n    if (included_methods is not None) and (deleted_methods is not None):\n        raise ValueError(\n            \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n        )\n\n    if included_methods is None:\n        included_methods = [\n            \"create\",\n            \"read\",\n            \"read_multi\",\n            \"read_paginated\",\n            \"update\",\n            \"delete\",\n            \"db_delete\",\n        ]\n    else:\n        try:\n            included_methods = CRUDMethods(\n                valid_methods=included_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n    if deleted_methods is None:\n        deleted_methods = []\n    else:\n        try:\n            deleted_methods = CRUDMethods(\n                valid_methods=deleted_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n    delete_description = \"Delete a\"\n    if self.delete_schema:\n        delete_description = \"Soft delete a\"\n\n    _primary_keys_path_suffix = \"/\".join(f\"{{{n}}}\" for n in self.primary_key_names)\n\n    if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"create\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}\",\n            self._create_item(),\n            methods=[\"POST\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(create_deps),\n            description=f\"Create a new {self.model.__name__} row in the database.\",\n        )\n\n    if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"read\")\n\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n            self._read_item(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(read_deps),\n            description=f\"Read a single {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"read_multi\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}\",\n            self._read_items(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(read_multi_deps),\n            description=f\"Read multiple {self.model.__name__} rows from the database with a limit and an offset.\",\n        )\n\n    if (\"read_paginated\" in included_methods) and (\n        \"read_paginated\" not in deleted_methods\n    ):\n        endpoint_name = self._get_endpoint_name(\"read_paginated\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}\",\n            self._read_paginated(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(read_paginated_deps),\n            description=f\"Read multiple {self.model.__name__} rows from the database with pagination.\",\n        )\n\n    if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"update\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n            self._update_item(),\n            methods=[\"PATCH\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(update_deps),\n            description=f\"Update an existing {self.model.__name__} row in the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"delete\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n            self._delete_item(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(delete_deps),\n            description=f\"{delete_description} {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\n        (\"db_delete\" in included_methods)\n        and (\"db_delete\" not in deleted_methods)\n        and self.delete_schema\n    ):\n        endpoint_name = self._get_endpoint_name(\"db_delete\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{_primary_keys_path_suffix}\",\n            self._db_delete(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(db_delete_deps),\n            description=f\"Permanently delete a {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n</code></pre>"},{"location":"api/fastcrud/","title":"FastCRUD API Reference","text":"<p><code>FastCRUD</code> is a base class for CRUD operations on a model, utilizing Pydantic schemas for data validation and serialization.</p>"},{"location":"api/fastcrud/#class-definition","title":"Class Definition","text":"<p>             Bases: <code>Generic[ModelType, CreateSchemaType, UpdateSchemaType, UpdateSchemaInternalType, DeleteSchemaType]</code></p> <p>Base class for CRUD operations on a model.</p> <p>This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model, utilizing Pydantic schemas for data validation and serialization.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[ModelType]</code> <p>The SQLAlchemy model type.</p> required <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".</p> <code>'updated_at'</code> <p>Methods:</p> Name Description <code>create</code> <p>Creates a new record in the database from the provided Pydantic schema.</p> <code>select</code> <p>Generates a SQL Alchemy <code>Select</code> statement with optional filtering and sorting.</p> <code>get</code> <p>Retrieves a single record based on filters. Supports advanced filtering through comparison operators like '__gt', '__lt', etc.</p> <code>exists</code> <p>Checks if a record exists based on the provided filters.</p> <code>count</code> <p>Counts the number of records matching the provided filters.</p> <code>get_multi</code> <p>Fetches multiple records with optional sorting, pagination, and model conversion.</p> <code>get_joined</code> <p>Performs a join operation with another model, supporting custom join conditions and selection of specific columns.</p> <code>get_multi_joined</code> <p>Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.</p> <code>get_multi_by_cursor</code> <p>Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.</p> <code>update</code> <p>Updates an existing record or multiple records based on specified filters.</p> <code>db_delete</code> <p>Hard deletes a record or multiple records from the database based on provided filters.</p> <code>delete</code> <p>Soft deletes a record if it has an \"is_deleted\" attribute; otherwise, performs a hard delete.</p> <p>Examples:</p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-1-basic-usage","title":"Example 1: Basic Usage","text":"<p>Create a FastCRUD instance for a User model and perform basic CRUD operations. <pre><code># Assuming you have a User model (either SQLAlchemy or SQLModel)\n# pydantic schemas for creation, update and deletion and an async session `db`\nCRUDUser = FastCRUD[User, UserCreateInternal, UserUpdate, UserUpdateInternal, UserDelete]\nuser_crud = CRUDUser(User)\n\n# If you don't care about typing, you can also just ignore the CRUDUser part\n# Straight up define user_crud with FastCRUD\nuser_crud = FastCRUD(User)\n\n# Create a new user\nnew_user = await user_crud.create(db, UserCreateSchema(name=\"Alice\"))\n# Read a user\nuser = await user_crud.get(db, id=new_user.id)\n# Update a user\nawait user_crud.update(db, UserUpdateSchema(email=\"alice@example.com\"), id=new_user.id)\n# Delete a user\nawait user_crud.delete(db, id=new_user.id)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-2-advanced-filtering-and-pagination","title":"Example 2: Advanced Filtering and Pagination","text":"<p>Use advanced filtering, sorting, and pagination for fetching records. <pre><code>product_crud = FastCRUD(Product)\nproducts = await product_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    sort_columns=['price'],\n    sort_orders=['asc'],\n)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-3-join-operations-with-custom-schemas","title":"Example 3: Join Operations with Custom Schemas","text":"<p>Perform join operations between two models using custom schemas for selection. <pre><code>order_crud = FastCRUD(Order)\norders = await order_crud.get_multi_joined(\n    db,\n    offset=0,\n    limit=5,\n    join_model=Product,\n    join_prefix=\"product_\",\n    schema_to_select=OrderReadSchema,\n    join_schema_to_select=ProductReadSchema,\n)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-4-cursor-pagination","title":"Example 4: Cursor Pagination","text":"<p>Implement cursor-based pagination for efficient data retrieval in large datasets. <pre><code>comment_crud = FastCRUD(Comment)\n\nfirst_page = await comment_crud.get_multi_by_cursor(db, limit=10)\nnext_cursor = first_page['next_cursor']\nsecond_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-5-dynamic-filtering-and-counting","title":"Example 5: Dynamic Filtering and Counting","text":"<p>Dynamically filter records based on various criteria and count the results. <pre><code>task_crud = FastCRUD(Task)\ncompleted_tasks = await task_crud.get_multi(\n    db,\n    status='completed'\n)\nhigh_priority_task_count = await task_crud.count(\n    db,\n    priority='high'\n)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-6-using-custom-column-names-for-soft-delete","title":"Example 6: Using Custom Column Names for Soft Delete","text":"<p>If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the FastCRUD instance. <pre><code>custom_user_crud = FastCRUD(\n    User,\n    is_deleted_column=\"archived\",\n    deleted_at_column=\"archived_at\"\n)\n# Now 'archived' and 'archived_at' will be used for soft delete operations.\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>class FastCRUD(\n    Generic[\n        ModelType,\n        CreateSchemaType,\n        UpdateSchemaType,\n        UpdateSchemaInternalType,\n        DeleteSchemaType,\n    ]\n):\n    \"\"\"\n    Base class for CRUD operations on a model.\n\n    This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model,\n    utilizing Pydantic schemas for data validation and serialization.\n\n    Args:\n        model: The SQLAlchemy model type.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".\n\n    Methods:\n        create:\n            Creates a new record in the database from the provided Pydantic schema.\n\n        select:\n            Generates a SQL Alchemy `Select` statement with optional filtering and sorting.\n\n        get:\n            Retrieves a single record based on filters. Supports advanced filtering through comparison operators like '__gt', '__lt', etc.\n\n        exists:\n            Checks if a record exists based on the provided filters.\n\n        count:\n            Counts the number of records matching the provided filters.\n\n        get_multi:\n            Fetches multiple records with optional sorting, pagination, and model conversion.\n\n        get_joined:\n            Performs a join operation with another model, supporting custom join conditions and selection of specific columns.\n\n        get_multi_joined:\n            Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.\n\n        get_multi_by_cursor:\n            Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.\n\n        update:\n            Updates an existing record or multiple records based on specified filters.\n\n        db_delete:\n            Hard deletes a record or multiple records from the database based on provided filters.\n\n        delete:\n            Soft deletes a record if it has an \"is_deleted\" attribute; otherwise, performs a hard delete.\n\n    Examples:\n        Example 1: Basic Usage\n        ----------------------\n        Create a FastCRUD instance for a User model and perform basic CRUD operations.\n        ```python\n        # Assuming you have a User model (either SQLAlchemy or SQLModel)\n        # pydantic schemas for creation, update and deletion and an async session `db`\n        CRUDUser = FastCRUD[User, UserCreateInternal, UserUpdate, UserUpdateInternal, UserDelete]\n        user_crud = CRUDUser(User)\n\n        # If you don't care about typing, you can also just ignore the CRUDUser part\n        # Straight up define user_crud with FastCRUD\n        user_crud = FastCRUD(User)\n\n        # Create a new user\n        new_user = await user_crud.create(db, UserCreateSchema(name=\"Alice\"))\n        # Read a user\n        user = await user_crud.get(db, id=new_user.id)\n        # Update a user\n        await user_crud.update(db, UserUpdateSchema(email=\"alice@example.com\"), id=new_user.id)\n        # Delete a user\n        await user_crud.delete(db, id=new_user.id)\n        ```\n\n        Example 2: Advanced Filtering and Pagination\n        --------------------------------------------\n        Use advanced filtering, sorting, and pagination for fetching records.\n        ```python\n        product_crud = FastCRUD(Product)\n        products = await product_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            sort_columns=['price'],\n            sort_orders=['asc'],\n        )\n        ```\n\n        Example 3: Join Operations with Custom Schemas\n        ----------------------------------------------\n        Perform join operations between two models using custom schemas for selection.\n        ```python\n        order_crud = FastCRUD(Order)\n        orders = await order_crud.get_multi_joined(\n            db,\n            offset=0,\n            limit=5,\n            join_model=Product,\n            join_prefix=\"product_\",\n            schema_to_select=OrderReadSchema,\n            join_schema_to_select=ProductReadSchema,\n        )\n        ```\n\n        Example 4: Cursor Pagination\n        ----------------------------\n        Implement cursor-based pagination for efficient data retrieval in large datasets.\n        ```python\n        comment_crud = FastCRUD(Comment)\n\n        first_page = await comment_crud.get_multi_by_cursor(db, limit=10)\n        next_cursor = first_page['next_cursor']\n        second_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n        ```\n\n        Example 5: Dynamic Filtering and Counting\n        -----------------------------------------\n        Dynamically filter records based on various criteria and count the results.\n        ```python\n        task_crud = FastCRUD(Task)\n        completed_tasks = await task_crud.get_multi(\n            db,\n            status='completed'\n        )\n        high_priority_task_count = await task_crud.count(\n            db,\n            priority='high'\n        )\n        ```\n\n        Example 6: Using Custom Column Names for Soft Delete\n        ----------------------------------------------------\n        If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the FastCRUD instance.\n        ```python\n        custom_user_crud = FastCRUD(\n            User,\n            is_deleted_column=\"archived\",\n            deleted_at_column=\"archived_at\"\n        )\n        # Now 'archived' and 'archived_at' will be used for soft delete operations.\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        model: type[ModelType],\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n    ) -&gt; None:\n        self.model = model\n        self.model_col_names = [col.key for col in model.__table__.columns]\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n        self._primary_keys = _get_primary_keys(self.model)\n\n    def _parse_filters(\n        self, model: Optional[Union[type[ModelType], AliasedClass]] = None, **kwargs\n    ) -&gt; list[BinaryExpression]:\n        model = model or self.model\n        filters = []\n        for key, value in kwargs.items():\n            if \"__\" in key:\n                field_name, op = key.rsplit(\"__\", 1)\n                column = getattr(model, field_name, None)\n                if column is None:\n                    raise ValueError(f\"Invalid filter column: {field_name}\")\n\n                if op == \"gt\":\n                    filters.append(column &gt; value)\n                elif op == \"lt\":\n                    filters.append(column &lt; value)\n                elif op == \"gte\":\n                    filters.append(column &gt;= value)\n                elif op == \"lte\":\n                    filters.append(column &lt;= value)\n                elif op == \"ne\":\n                    filters.append(column != value)\n                elif op == \"in\":\n                    if not isinstance(value, (tuple, list, set)):\n                        raise ValueError(\"in filter must be tuple, list or set\")\n                    filters.append(column.in_(value))\n                elif op == \"not_in\":\n                    if not isinstance(value, (tuple, list, set)):\n                        raise ValueError(\"in filter must be tuple, list or set\")\n                    filters.append(column.not_in(value))\n            else:\n                column = getattr(model, key, None)\n                if column is not None:\n                    filters.append(column == value)\n\n        return filters\n\n    def _apply_sorting(\n        self,\n        stmt: Select,\n        sort_columns: Union[str, list[str]],\n        sort_orders: Optional[Union[str, list[str]]] = None,\n    ) -&gt; Select:\n        \"\"\"\n        Apply sorting to a SQLAlchemy query based on specified column names and sort orders.\n\n        Args:\n            stmt: The SQLAlchemy Select statement to which sorting will be applied.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding\n                to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n\n        Raises:\n            ValueError: Raised if sort orders are provided without corresponding sort columns,\n                or if an invalid sort order is provided (not 'asc' or 'desc').\n            ArgumentError: Raised if an invalid column name is provided that does not exist in the model.\n\n        Returns:\n            The modified Select statement with sorting applied.\n\n        Examples:\n            Applying ascending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'name')\n\n            Applying descending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'age', 'desc')\n\n            Applying mixed sort orders on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'], ['asc', 'desc'])\n\n            Applying ascending sort on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'])\n\n        Note:\n            This method modifies the passed Select statement in-place by applying the order_by clause\n            based on the provided column names and sort orders.\n        \"\"\"\n        if sort_orders and not sort_columns:\n            raise ValueError(\"Sort orders provided without corresponding sort columns.\")\n\n        if sort_columns:\n            if not isinstance(sort_columns, list):\n                sort_columns = [sort_columns]\n\n            if sort_orders:\n                if not isinstance(sort_orders, list):\n                    sort_orders = [sort_orders] * len(sort_columns)\n                if len(sort_columns) != len(sort_orders):\n                    raise ValueError(\n                        \"The length of sort_columns and sort_orders must match.\"\n                    )\n\n                for idx, order in enumerate(sort_orders):\n                    if order not in [\"asc\", \"desc\"]:\n                        raise ValueError(\n                            f\"Invalid sort order: {order}. Only 'asc' or 'desc' are allowed.\"\n                        )\n\n            validated_sort_orders = (\n                [\"asc\"] * len(sort_columns) if not sort_orders else sort_orders\n            )\n\n            for idx, column_name in enumerate(sort_columns):\n                column = getattr(self.model, column_name, None)\n                if not column:\n                    raise ArgumentError(f\"Invalid column name: {column_name}\")\n\n                order = validated_sort_orders[idx]\n                stmt = stmt.order_by(asc(column) if order == \"asc\" else desc(column))\n\n        return stmt\n\n    def _prepare_and_apply_joins(\n        self,\n        stmt: Select,\n        joins_config: list[JoinConfig],\n        use_temporary_prefix: bool = False,\n    ):\n        \"\"\"\n        Applies joins to the given SQL statement based on a list of JoinConfig objects.\n\n        Args:\n            stmt: The initial SQL statement.\n            joins_config: Configurations for all joins.\n            use_temporary_prefix: Whether to use or not an aditional prefix for joins. Default False.\n\n        Returns:\n            Select: The modified SQL statement with joins applied.\n        \"\"\"\n        for join in joins_config:\n            model = join.alias or join.model\n            join_select = _extract_matching_columns_from_schema(\n                model,\n                join.schema_to_select,\n                join.join_prefix,\n                join.alias,\n                use_temporary_prefix,\n            )\n            joined_model_filters = self._parse_filters(\n                model=model, **(join.filters or {})\n            )\n\n            if join.join_type == \"left\":\n                stmt = stmt.outerjoin(model, join.join_on).add_columns(*join_select)\n            elif join.join_type == \"inner\":\n                stmt = stmt.join(model, join.join_on).add_columns(*join_select)\n            else:  # pragma: no cover\n                raise ValueError(f\"Unsupported join type: {join.join_type}.\")\n            if joined_model_filters:\n                stmt = stmt.filter(*joined_model_filters)\n\n        return stmt\n\n    async def create(\n        self, db: AsyncSession, object: CreateSchemaType, commit: bool = True\n    ) -&gt; ModelType:\n        \"\"\"\n        Create a new record in the database.\n\n        Args:\n            db: The SQLAlchemy async session.\n            object: The Pydantic schema containing the data to be saved.\n            commit: If True, commits the transaction immediately. Default is True.\n\n        Returns:\n            The created database object.\n        \"\"\"\n        object_dict = object.model_dump()\n        db_object: ModelType = self.model(**object_dict)\n        db.add(db_object)\n        if commit:\n            await db.commit()\n        return db_object\n\n    async def select(\n        self,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        **kwargs,\n    ) -&gt; Select:\n        \"\"\"\n        Constructs a SQL Alchemy `Select` statement with optional column selection, filtering, and sorting.\n        This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n        Supported operators include:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            schema_to_select: Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.\n            sort_columns: A single column name or list of column names to sort the query results by. Must be used in conjunction with sort_orders.\n            sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders, corresponding to each column in sort_columns. If not specified, defaults to ascending order for all sort_columns.\n\n        Returns:\n            Selectable: An SQL Alchemy `Select` statement object that can be executed or further modified.\n\n        Examples:\n            Selecting specific columns with filtering and sorting:\n            ```python\n            stmt = await crud.select(\n                schema_to_select=UserReadSchema,\n                sort_columns=['age', 'name'],\n                sort_orders=['asc', 'desc'],\n                age__gt=18\n            )\n            ```\n\n            Creating a statement to select all users without any filters:\n            ```python\n            stmt = await crud.select()\n            ```\n\n            Selecting users with a specific role, ordered by name:\n            ```python\n            stmt = await crud.select(\n                schema_to_select=UserReadSchema,\n                sort_columns='name',\n                role='admin'\n            )\n            ```\n        Note:\n            This method does not execute the generated SQL statement.\n            Use `db.execute(stmt)` to run the query and fetch results.\n        \"\"\"\n        to_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        filters = self._parse_filters(**kwargs)\n        stmt = select(*to_select).filter(*filters)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n        return stmt\n\n    async def get(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict, BaseModel]]:\n        \"\"\"\n        Fetches a single record based on specified filters.\n        This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n        Supported operators include:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The database session to use for the operation.\n            schema_to_select: Optional Pydantic schema for selecting specific columns.\n            return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n            one_or_none: Flag to get strictly one or no result. Multiple results are not allowed.\n            **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n        Raises:\n            ValueError: If return_as_model is True but schema_to_select is not provided.\n\n        Returns:\n            A dictionary or a Pydantic model instance of the fetched database row, or None if no match is found.\n\n        Examples:\n            Fetch a user by ID:\n            ```python\n            user = await crud.get(db, id=1)\n            ```\n\n            Fetch a user with an age greater than 30:\n            ```python\n            user = await crud.get(db, age__gt=30)\n            ```\n\n            Fetch a user with a registration date before Jan 1, 2020:\n            ```python\n            user = await crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Fetch a user not equal to a specific username:\n            ```python\n            user = await crud.get(db, username__ne='admin')\n            ```\n        \"\"\"\n        stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n        db_row = await db.execute(stmt)\n        result: Optional[Row] = db_row.one_or_none() if one_or_none else db_row.first()\n        if result is None:\n            return None\n        out: dict = dict(result._mapping)\n        if not return_as_model:\n            return out\n        if not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        return schema_to_select(**out)\n\n    def _get_pk_dict(self, instance):\n        return {pk.name: getattr(instance, pk.name) for pk in self._primary_keys}\n\n    async def upsert(\n        self,\n        db: AsyncSession,\n        instance: Union[UpdateSchemaType, CreateSchemaType],\n        schema_to_select: Optional[type[BaseModel]] = None,\n        return_as_model: bool = False,\n    ) -&gt; Union[BaseModel, Dict[str, Any], None]:\n        \"\"\"Update the instance or create it if it doesn't exists.\n        Note: This method will perform two transactions to the database (get and create or update).\n\n        Args:\n            db (AsyncSession): The database session to use for the operation.\n            instance (Union[UpdateSchemaType, type[BaseModel]]): A Pydantic schema representing the instance.\n            schema_to_select (Optional[type[BaseModel]], optional): Optional Pydantic schema for selecting specific columns. Defaults to None.\n            return_as_model (bool, optional): If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n\n        Returns:\n            BaseModel: the created or updated instance\n        \"\"\"\n        _pks = self._get_pk_dict(instance)\n        schema_to_select = schema_to_select or type(instance)\n        db_instance = await self.get(\n            db,\n            schema_to_select=schema_to_select,\n            return_as_model=return_as_model,\n            **_pks,\n        )\n        if db_instance is None:\n            db_instance = await self.create(db, instance)  # type: ignore\n            db_instance = schema_to_select.model_validate(\n                db_instance, from_attributes=True\n            )\n        else:\n            await self.update(db, instance)  # type: ignore\n            db_instance = await self.get(\n                db,\n                schema_to_select=schema_to_select,\n                return_as_model=return_as_model,\n                **_pks,\n            )\n\n        return db_instance\n\n    async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n        \"\"\"\n        Checks if any records exist that match the given filter conditions.\n        This method supports advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The database session to use for the operation.\n            **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n        Returns:\n            True if at least one record matches the filter conditions, False otherwise.\n\n        Examples:\n            Fetch a user by ID exists:\n            ```python\n            exists = await crud.exists(db, id=1)\n            ```\n\n            Check if any user is older than 30:\n            ```python\n            exists = await crud.exists(db, age__gt=30)\n            ```\n\n            Check if any user registered before Jan 1, 2020:\n            ```python\n            exists = await crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Check if a username other than 'admin' exists:\n            ```python\n            exists = await crud.exists(db, username__ne='admin')\n            ```\n        \"\"\"\n        filters = self._parse_filters(**kwargs)\n        stmt = select(self.model).filter(*filters).limit(1)\n\n        result = await db.execute(stmt)\n        return result.first() is not None\n\n    async def count(\n        self,\n        db: AsyncSession,\n        joins_config: Optional[list[JoinConfig]] = None,\n        **kwargs: Any,\n    ) -&gt; int:\n        \"\"\"\n        Counts records that match specified filters, supporting advanced filtering through comparison operators:\n            '__gt' (greater than), '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n        Can also count records based on a configuration of joins, useful for complex queries involving relationships.\n\n        Args:\n            db: The database session to use for the operation.\n            joins_config: Optional configuration for applying joins in the count query.\n            **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n        Returns:\n            The total number of records matching the filter conditions.\n\n        Examples:\n            Count users by ID:\n            ```python\n            count = await crud.count(db, id=1)\n            ```\n\n            Count users older than 30:\n            ```python\n            count = await crud.count(db, age__gt=30)\n            ```\n\n            Count users with a username other than 'admin':\n            ```python\n            count = await crud.count(db, username__ne='admin')\n            ```\n\n            Count projects with at least one participant (many-to-many relationship):\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\"\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\"\n                )\n            ]\n            count = await crud.count(db, joins_config=joins_config)\n            ```\n\n            Count projects by a specific participant name (filter applied on a joined model):\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\"\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'name': 'Jane Doe'}\n                )\n            ]\n            count = await crud.count(db, joins_config=joins_config)\n            ```\n        \"\"\"\n        primary_filters = self._parse_filters(**kwargs)\n\n        if joins_config is not None:\n            primary_keys = [p.name for p in _get_primary_keys(self.model)]\n            if not any(primary_keys):  # pragma: no cover\n                raise ValueError(\n                    f\"The model '{self.model.__name__}' does not have a primary key defined, which is required for counting with joins.\"\n                )\n            to_select = [\n                getattr(self.model, pk).label(f\"distinct_{pk}\") for pk in primary_keys\n            ]\n            base_query = select(*to_select)\n\n            for join in joins_config:\n                join_model = join.alias or join.model\n                join_filters = (\n                    self._parse_filters(model=join_model, **join.filters)\n                    if join.filters\n                    else []\n                )\n\n                if join.join_type == \"inner\":\n                    base_query = base_query.join(join_model, join.join_on)\n                else:\n                    base_query = base_query.outerjoin(join_model, join.join_on)\n\n                if join_filters:\n                    base_query = base_query.where(*join_filters)\n\n            if primary_filters:\n                base_query = base_query.where(*primary_filters)\n\n            subquery = base_query.subquery()\n            count_query = select(func.count()).select_from(subquery)\n        else:\n            count_query = select(func.count()).select_from(self.model)\n            if primary_filters:\n                count_query = count_query.where(*primary_filters)\n\n        total_count: Optional[int] = await db.scalar(count_query)\n        if total_count is None:\n            raise ValueError(\"Could not find the count.\")\n\n        return total_count\n\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        return_total_count: bool = True,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetches multiple records based on filters, supporting sorting, pagination, and advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The database session to use for the operation.\n            offset: Starting index for records to fetch, useful for pagination.\n            limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n            sort_columns: Column names to sort the results by.\n            sort_orders: Corresponding sort orders ('asc', 'desc') for each column in sort_columns.\n            return_as_model: If True, returns data as instances of the specified Pydantic model.\n            return_total_count: If True, also returns the total count of rows with the selected filters. Useful for pagination.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n        Returns:\n            A dictionary containing 'data' with fetched records and 'total_count' indicating the total number of records matching the filters.\n\n        Raises:\n            ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n        Examples:\n            Fetch the first 10 users:\n            ```python\n            users = await crud.get_multi(db, 0, 10)\n            ```\n\n            Fetch next 10 users with sorted by username:\n            ```python\n            users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n            ```\n\n            Fetch 10 users older than 30, sorted by age in descending order:\n            ```python\n            get_multi(db, offset=0, limit=10, age__gt=30, sort_columns='age', sort_orders='desc')\n            ```\n\n            Fetch 10 users with a registration date before Jan 1, 2020:\n            ```python\n            get_multi(db, offset=0, limit=10, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Fetch 10 users with a username other than 'admin', returning as model instances (ensure appropriate schema is passed):\n            ```python\n            get_multi(db, offset=0, limit=10, username__ne='admin', schema_to_select=UserSchema, return_as_model=True)\n            ```\n\n            Fetch users with filtering and multiple column sorting:\n            ```python\n            users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n            ```\n        \"\"\"\n        if (limit is not None and limit &lt; 0) or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        stmt = await self.select(\n            schema_to_select=schema_to_select,\n            sort_columns=sort_columns,\n            sort_orders=sort_orders,\n            **kwargs,\n        )\n\n        if offset:\n            stmt = stmt.offset(offset)\n        if limit is not None:\n            stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        response: dict[str, Any] = {\"data\": data}\n\n        if return_total_count:\n            total_count = await self.count(db=db, **kwargs)\n            response[\"total_count\"] = total_count\n\n        if return_as_model:\n            if not schema_to_select:\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            try:\n                model_data = [schema_to_select(**row) for row in data]\n                response[\"data\"] = model_data\n            except ValidationError as e:\n                raise ValueError(\n                    f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                )\n\n        return response\n\n    async def get_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        join_model: Optional[type[DeclarativeBase]] = None,\n        join_on: Optional[Union[Join, BinaryExpression]] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[BaseModel]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass] = None,\n        join_filters: Optional[dict] = None,\n        joins_config: Optional[list[JoinConfig]] = None,\n        nest_joins: bool = False,\n        relationship_type: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"\n        Fetches a single record with one or multiple joins on other models. If 'join_on' is not provided, the method attempts\n        to automatically detect the join condition using foreign key relationships. For multiple joins, use 'joins_config' to\n        specify each join configuration. Advanced filters supported:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The SQLAlchemy async session.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_model: The model to join with.\n            join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n            alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n            join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n            joins_config: A list of JoinConfig instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.\n            nest_joins: If True, nested data structures will be returned where joined model data are nested under the join_prefix as a dictionary.\n            relationship_type: Specifies the relationship type, such as 'one-to-one' or 'one-to-many'. Used to determine how to nest the joined data. If None, uses one-to-one.\n            **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary representing the joined record, or None if no record matches the criteria.\n\n        Raises:\n            ValueError: If both single join parameters and 'joins_config' are used simultaneously.\n            ArgumentError: If any provided model in 'joins_config' is not recognized or invalid.\n            NoResultFound: If no record matches the criteria with the provided filters.\n\n        Examples:\n            Simple example: Joining User and Tier models without explicitly providing join_on\n            ```python\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Tier,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema\n            )\n            ```\n\n            Fetch a user and their associated tier, filtering by user ID:\n            ```python\n            get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, id=1)\n            ```\n\n            Fetch a user and their associated tier, where the user's age is greater than 30:\n            ```python\n            get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, age__gt=30)\n            ```\n\n            Fetch a user and their associated tier, excluding users with the 'admin' username:\n            ```python\n            get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, username__ne='admin')\n            ```\n\n            Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n            ```python\n            from sqlalchemy import and_\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                username=\"john_doe\"\n            )\n            ```\n\n            Example of using 'joins_config' for multiple joins:\n            ```python\n            from fastcrud import JoinConfig\n\n            result = await crud_user.get_joined(\n                db=session,\n                schema_to_select=UserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=TierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=DepartmentSchema,\n                        join_type=\"inner\",\n                    )\n                ]\n            )\n            ```\n\n            Using `alias` for joining the same model multiple times:\n            ```python\n            from fastcrud import aliased\n\n            owner_alias = aliased(ModelTest, name=\"owner\")\n            user_alias = aliased(ModelTest, name=\"user\")\n\n            result = await crud.get_joined(\n                db=session,\n                schema_to_select=BookingSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.owner_id == owner_alias.id,\n                        join_prefix=\"owner_\",\n                        alias=owner_alias,\n                        schema_to_select=UserSchema\n                    ),\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.user_id == user_alias.id,\n                        join_prefix=\"user_\",\n                        alias=user_alias,\n                        schema_to_select=UserSchema\n                    )\n                ],\n                id=1\n            )\n            ```\n\n            Fetching a single project and its associated participants where a participant has a specific role:\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\"\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'role': 'Designer'}\n                )\n            ]\n            project = await crud.get_joined(\n                db=session,\n                schema_to_select=ProjectSchema,\n                joins_config=joins_config\n            )\n            ```\n\n            Example of using 'joins_config' for multiple joins with nested joins enabled:\n            ```python\n            from fastcrud import JoinConfig\n\n            result = await crud_user.get_joined(\n                db=session,\n                schema_to_select=UserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=TierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=DepartmentSchema,\n                        join_type=\"inner\",\n                    )\n                ],\n                nest_joins=True\n            )\n            # Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n            ```\n\n            Example using one-to-one relationship:\n            ```python\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Profile,\n                join_on=User.profile_id == Profile.id,\n                schema_to_select=UserSchema,\n                join_schema_to_select=ProfileSchema,\n                relationship_type='one-to-one' # note that this is the default behavior\n            )\n            # Expect 'result' to have 'profile' as a nested dictionary\n            ```\n\n            Example using one-to-many relationship:\n            ```python\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Post,\n                join_on=User.id == Post.user_id,\n                schema_to_select=UserSchema,\n                join_schema_to_select=PostSchema,\n                relationship_type='one-to-many',\n                nest_joins=True\n            )\n            # Expect 'result' to have 'posts' as a nested list of dictionaries\n        \"\"\"\n        if joins_config and (\n            join_model or join_prefix or join_on or join_schema_to_select or alias\n        ):\n            raise ValueError(\n                \"Cannot use both single join parameters and joins_config simultaneously.\"\n            )\n        elif not joins_config and not join_model:\n            raise ValueError(\"You need one of join_model or joins_config.\")\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model,\n            schema=schema_to_select,\n        )\n        stmt: Select = select(*primary_select).select_from(self.model)\n\n        join_definitions = joins_config if joins_config else []\n        if join_model:\n            join_definitions.append(\n                JoinConfig(\n                    model=join_model,\n                    join_on=join_on,\n                    join_prefix=join_prefix,\n                    schema_to_select=join_schema_to_select,\n                    join_type=join_type,\n                    alias=alias,\n                    filters=join_filters,\n                    relationship_type=relationship_type,\n                )\n            )\n\n        stmt = self._prepare_and_apply_joins(\n            stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n        )\n        primary_filters = self._parse_filters(**kwargs)\n        if primary_filters:\n            stmt = stmt.filter(*primary_filters)\n\n        db_rows = await db.execute(stmt)\n        if any(join.relationship_type == \"one-to-many\" for join in join_definitions):\n            if nest_joins is False:  # pragma: no cover\n                raise ValueError(\n                    \"Cannot use one-to-many relationship with nest_joins=False\"\n                )\n            results = db_rows.fetchall()\n            data_list = [dict(row._mapping) for row in results]\n        else:\n            result = db_rows.first()\n            if result is not None:\n                data_list = [dict(result._mapping)]\n            else:\n                data_list = []\n\n        if data_list:\n            if nest_joins:\n                nested_data: dict = {}\n                for data in data_list:\n                    nested_data = _nest_join_data(\n                        data,\n                        join_definitions,\n                        nested_data=nested_data,\n                    )\n                return nested_data\n            return data_list[0]\n\n        return None\n\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        join_model: Optional[type[ModelType]] = None,\n        join_on: Optional[Any] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[BaseModel]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass[Any]] = None,\n        join_filters: Optional[dict] = None,\n        nest_joins: bool = False,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        joins_config: Optional[list[JoinConfig]] = None,\n        return_total_count: bool = True,\n        relationship_type: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion,\n        supporting advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The SQLAlchemy async session.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_model: The model to join with.\n            join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n            alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n            join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n            nest_joins: If True, nested data structures will be returned where joined model data are nested under the join_prefix as a dictionary.\n            offset: The offset (number of records to skip) for pagination.\n            limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n            return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n            joins_config: List of JoinConfig instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.\n            return_total_count: If True, also returns the total count of rows with the selected filters. Useful for pagination.\n            relationship_type: Specifies the relationship type, such as 'one-to-one' or 'one-to-many'. Used to determine how to nest the joined data. If None, uses one-to-one.\n            **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n        Raises:\n            ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n                        Also if both 'joins_config' and any of the single join parameters are provided or none of 'joins_config' and 'join_model' is provided.\n\n        Examples:\n            Fetching multiple User records joined with Tier records, using left join, returning raw data:\n            ```python\n            users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10\n            )\n            ```\n\n            Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n            ```python\n            users = get_multi_joined(\n                db,\n                User,\n                Tier,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                age__gt=30,\n                sort_columns='username',\n                sort_orders='asc'\n            )\n            ```\n\n            Fetch users joined with their tiers, excluding users with 'admin' username, returning as model instances:\n            ```python\n            users = get_multi_joined(\n                db,\n                User,\n                Tier,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                username__ne='admin',\n                return_as_model=True\n            )\n            ```\n\n            Fetching and sorting by username in descending order, returning as Pydantic model:\n            ```python\n            users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10,\n                sort_columns=['username'],\n                sort_orders=['desc'],\n                return_as_model=True\n            )\n            ```\n\n            Fetching with complex conditions and custom join, returning as Pydantic model:\n            ```python\n            users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_on=User.tier_id == Tier.id,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10,\n                is_active=True,\n                return_as_model=True\n            )\n            ```\n\n            Example using 'joins_config' for multiple joins:\n            ```python\n            from fastcrud import JoinConfig\n\n            users = await crud_user.get_multi_joined(\n                db=session,\n                schema_to_select=UserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=TierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=DepartmentSchema,\n                        join_type=\"inner\",\n                    )\n                ],\n                offset=0,\n                limit=10,\n                sort_columns='username',\n                sort_orders='asc'\n            )\n            ```\n\n            Example using `alias` for multiple joins, with pagination, sorting, and model conversion:\n            ```python\n            from fastcrud import JoinConfig, FastCRUD, aliased\n\n            # Aliasing for self-joins or multiple joins on the same table\n            owner_alias = aliased(ModelTest, name=\"owner\")\n            user_alias = aliased(ModelTest, name=\"user\")\n\n            # Initialize your FastCRUD instance for BookingModel\n            crud = FastCRUD(BookingModel)\n\n            result = await crud.get_multi_joined(\n                db=session,\n                schema_to_select=BookingSchema,  # Primary model schema\n                joins_config=[\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.owner_id == owner_alias.id,\n                        join_prefix=\"owner_\",\n                        alias=owner_alias,\n                        schema_to_select=UserSchema  # Schema for the joined model\n                    ),\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.user_id == user_alias.id,\n                        join_prefix=\"user_\",\n                        alias=user_alias,\n                        schema_to_select=UserSchema\n                    )\n                ],\n                offset=10,  # Skip the first 10 records\n                limit=5,  # Fetch up to 5 records\n                sort_columns=['booking_date'],  # Sort by booking_date\n                sort_orders=['desc']  # In descending order\n            )\n            ```\n\n            Fetching multiple project records and their associated participants where participants have a specific role:\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\"\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'role': 'Developer'}\n                )\n            ]\n            projects = await crud.get_multi_joined(\n                db=session,\n                schema_to_select=ProjectSchema,\n                joins_config=joins_config,\n                limit=10\n            )\n            ```\n\n            Fetching a list of projects, each with nested details of associated tasks and task creators, using nested joins:\n            ```python\n            projects = await crud.get_multi_joined(\n                db=session,\n                schema_to_select=ProjectSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Task,\n                        join_on=Project.id == Task.project_id,\n                        join_prefix=\"task_\",\n                        schema_to_select=TaskSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=User,\n                        join_on=Task.creator_id == User.id,\n                        join_prefix=\"creator_\",\n                        schema_to_select=UserSchema,\n                        join_type=\"left\",\n                        alias=aliased(User, name=\"task_creator\")\n                    )\n                ],\n                nest_joins=True,\n                offset=0,\n                limit=5,\n                sort_columns='project_name',\n                sort_orders='asc'\n            )\n        ```\n\n        Example using one-to-one relationship:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Profile,\n            join_on=User.profile_id == Profile.id,\n            schema_to_select=UserSchema,\n            join_schema_to_select=ProfileSchema,\n            relationship_type='one-to-one', # note that this is the default behavior\n            offset=0,\n            limit=10\n        )\n        # Expect 'profile' to be nested as a dictionary under each user\n        ```\n\n        Example using one-to-many relationship:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Post,\n            join_on=User.id == Post.user_id,\n            schema_to_select=UserSchema,\n            join_schema_to_select=PostSchema,\n            relationship_type='one-to-many',\n            nest_joins=True,\n            offset=0,\n            limit=10\n        )\n        # Expect 'posts' to be nested as a list of dictionaries under each user\n        ```\n        \"\"\"\n        if joins_config and (\n            join_model\n            or join_prefix\n            or join_on\n            or join_schema_to_select\n            or alias\n            or relationship_type\n        ):\n            raise ValueError(\n                \"Cannot use both single join parameters and joins_config simultaneously.\"\n            )\n        elif not joins_config and not join_model:\n            raise ValueError(\"You need one of join_model or joins_config.\")\n\n        if (limit is not None and limit &lt; 0) or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        stmt: Select = select(*primary_select)\n\n        join_definitions = joins_config if joins_config else []\n        if join_model:\n            join_definitions.append(\n                JoinConfig(\n                    model=join_model,\n                    join_on=join_on\n                    or _auto_detect_join_condition(self.model, join_model),\n                    join_prefix=join_prefix,\n                    schema_to_select=join_schema_to_select,\n                    join_type=join_type,\n                    alias=alias,\n                    filters=join_filters,\n                    relationship_type=relationship_type,\n                )\n            )\n\n        stmt = self._prepare_and_apply_joins(\n            stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n        )\n\n        primary_filters = self._parse_filters(**kwargs)\n        if primary_filters:\n            stmt = stmt.filter(*primary_filters)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n        if offset:\n            stmt = stmt.offset(offset)\n        if limit is not None:\n            stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data: list[Union[dict, BaseModel]] = []\n\n        for row in result.mappings().all():\n            row_dict = dict(row)\n\n            if nest_joins:\n                row_dict = _nest_join_data(\n                    data=row_dict,\n                    join_definitions=join_definitions,\n                )\n\n            if return_as_model:\n                if schema_to_select is None:\n                    raise ValueError(\n                        \"schema_to_select must be provided when return_as_model is True.\"\n                    )\n                try:\n                    model_instance = schema_to_select(**row_dict)\n                    data.append(model_instance)\n                except ValidationError as e:\n                    raise ValueError(\n                        f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                    )\n            else:\n                data.append(row_dict)\n\n        if nest_joins and any(\n            join.relationship_type == \"one-to-many\" for join in join_definitions\n        ):\n            nested_data = _nest_multi_join_data(\n                base_primary_key=self._primary_keys[0].name,\n                data=data,\n                joins_config=join_definitions,\n                return_as_model=return_as_model,\n                schema_to_select=schema_to_select if return_as_model else None,\n                nested_schema_to_select={\n                    (\n                        join.join_prefix.rstrip(\"_\")\n                        if join.join_prefix\n                        else join.model.__name__\n                    ): join.schema_to_select\n                    for join in join_definitions\n                    if join.schema_to_select\n                },\n            )\n        else:\n            nested_data = data\n\n        response: dict[str, Any] = {\"data\": nested_data}\n\n        if return_total_count:\n            total_count: int = await self.count(\n                db=db, joins_config=joins_config, **kwargs\n            )\n            response[\"total_count\"] = total_count\n\n        return response\n\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n        It supports advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The SQLAlchemy async session.\n            cursor: The cursor value to start fetching records from. Defaults to None.\n            limit: Maximum number of rows to fetch.\n            schema_to_select: Pydantic schema for selecting specific columns.\n            sort_column: Column name to use for sorting and cursor pagination.\n            sort_order: Sorting direction, either 'asc' or 'desc'.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n        Returns:\n            A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.\n\n        Examples:\n            Fetch the first set of records (e.g., the first page in an infinite scrolling scenario)\n            ```python\n            first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\n            Fetch the next set of records using the cursor from the first page\n            next_cursor = first_page['next_cursor']\n            second_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n            ```\n\n            Fetch records with age greater than 30 using cursor-based pagination:\n            ```python\n            get_multi_by_cursor(db, limit=10, sort_column='age', sort_order='asc', age__gt=30)\n            ```\n\n            Fetch records excluding a specific username using cursor-based pagination:\n            ```python\n            get_multi_by_cursor(db, limit=10, sort_column='username', sort_order='asc', username__ne='admin')\n            ```\n\n        Note:\n            This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n            Make sure the column used for cursor pagination is indexed for performance.\n            This method assumes that your records can be ordered by a unique, sequential field (like `id` or `created_at`).\n        \"\"\"\n        if limit == 0:\n            return {\"data\": [], \"next_cursor\": None}\n\n        stmt = await self.select(\n            schema_to_select=schema_to_select,\n            **kwargs,\n        )\n\n        if cursor:\n            if sort_order == \"asc\":\n                stmt = stmt.filter(getattr(self.model, sort_column) &gt; cursor)\n            else:\n                stmt = stmt.filter(getattr(self.model, sort_column) &lt; cursor)\n\n        stmt = stmt.order_by(\n            asc(getattr(self.model, sort_column))\n            if sort_order == \"asc\"\n            else desc(getattr(self.model, sort_column))\n        )\n        stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        next_cursor = None\n        if len(data) == limit:\n            if sort_order == \"asc\":\n                next_cursor = data[-1][sort_column]\n            else:\n                data[0][sort_column]\n\n        return {\"data\": data, \"next_cursor\": next_cursor}\n\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        allow_multiple: bool = False,\n        commit: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n        It supports advanced filtering through comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The database session to use for the operation.\n            object: A Pydantic schema or dictionary containing the update data.\n            allow_multiple: If True, allows updating multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n            commit: If True, commits the transaction immediately. Default is True.\n            **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n        Returns:\n            None\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n            ValueError: If extra fields not present in the model are provided in the update data.\n\n        Examples:\n            Update a user's email based on their ID:\n            ```python\n            update(db, {'email': 'new_email@example.com'}, id=1)\n            ```\n\n            Update users' statuses to 'inactive' where age is greater than 30 and allow updates to multiple records:\n            ```python\n            update(db, {'status': 'inactive'}, allow_multiple=True, age__gt=30)\n            ```\n\n            Update a user's username excluding specific user ID and prevent multiple updates:\n            ```python\n            update(db, {'username': 'new_username'}, id__ne=1, allow_multiple=False)\n            ```\n        \"\"\"\n        if not allow_multiple and (total_count := await self.count(db, **kwargs)) &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to update, found {total_count}.\"\n            )\n\n        if isinstance(object, dict):\n            update_data = object\n        else:\n            update_data = object.model_dump(exclude_unset=True)\n\n        updated_at_col = getattr(self.model, self.updated_at_column, None)\n        if updated_at_col:\n            update_data[self.updated_at_column] = datetime.now(timezone.utc)\n\n        update_data_keys = set(update_data.keys())\n        model_columns = {column.name for column in inspect(self.model).c}\n        extra_fields = update_data_keys - model_columns\n        if extra_fields:\n            raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n        filters = self._parse_filters(**kwargs)\n        stmt = update(self.model).filter(*filters).values(update_data)\n\n        await db.execute(stmt)\n        if commit:\n            await db.commit()\n\n    async def db_delete(\n        self,\n        db: AsyncSession,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Deletes a record or multiple records from the database based on specified filters, with support for advanced filtering through comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The database session to use for the operation.\n            allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n            commit: If True, commits the transaction immediately. Default is True.\n            **kwargs: Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n        Returns:\n            None\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n\n        Examples:\n            Delete a user based on their ID:\n            ```python\n            db_delete(db, id=1)\n            ```\n\n            Delete users older than 30 years and allow deletion of multiple records:\n            ```python\n            db_delete(db, allow_multiple=True, age__gt=30)\n            ```\n\n            Delete a user with a specific username, ensuring only one record is deleted:\n            ```python\n            db_delete(db, username='unique_username', allow_multiple=False)\n            ```\n        \"\"\"\n        if not allow_multiple and (total_count := await self.count(db, **kwargs)) &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to delete, found {total_count}.\"\n            )\n\n        filters = self._parse_filters(**kwargs)\n        stmt = delete(self.model).filter(*filters)\n        await db.execute(stmt)\n        if commit:\n            await db.commit()\n\n    async def delete(\n        self,\n        db: AsyncSession,\n        db_row: Optional[Row] = None,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Soft deletes a record or optionally multiple records if it has an \"is_deleted\" attribute, otherwise performs a hard delete, based on specified filters.\n        Supports advanced filtering through comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to),\n            '__ne' (not equal),\n            '__in' (included in [tuple, list or set]),\n            '__not_in' (not included in [tuple, list or set]).\n\n        Args:\n            db: The database session to use for the operation.\n            db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n            allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n            commit: If True, commits the transaction immediately. Default is True.\n            **kwargs: Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n            NoResultFound: If no record matches the filters.\n\n        Returns:\n            None\n\n        Examples:\n            Soft delete a specific user by ID:\n            ```python\n            delete(db, id=1)\n            ```\n\n            Hard delete users with account creation dates before 2020, allowing deletion of multiple records:\n            ```python\n            delete(db, allow_multiple=True, creation_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Soft delete a user with a specific email, ensuring only one record is deleted:\n            ```python\n            delete(db, email='unique@example.com', allow_multiple=False)\n            ```\n        \"\"\"\n        filters = self._parse_filters(**kwargs)\n        if db_row:\n            if hasattr(db_row, self.is_deleted_column) and hasattr(\n                db_row, self.deleted_at_column\n            ):\n                setattr(db_row, self.is_deleted_column, True)\n                setattr(db_row, self.deleted_at_column, datetime.now(timezone.utc))\n                if commit:\n                    await db.commit()\n            else:\n                await db.delete(db_row)\n            if commit:\n                await db.commit()\n            return\n\n        total_count = await self.count(db, **kwargs)\n        if total_count == 0:\n            raise NoResultFound(\"No record found to delete.\")\n        if not allow_multiple and total_count &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to delete, found {total_count}.\"\n            )\n\n        if self.is_deleted_column in self.model_col_names:\n            update_stmt = (\n                update(self.model)\n                .filter(*filters)\n                .values(is_deleted=True, deleted_at=datetime.now(timezone.utc))\n            )\n            await db.execute(update_stmt)\n        else:\n            delete_stmt = delete(self.model).filter(*filters)\n            await db.execute(delete_stmt)\n\n        if commit:\n            await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.count","title":"<code>count(db, joins_config=None, **kwargs)</code>  <code>async</code>","text":"<p>Counts records that match specified filters, supporting advanced filtering through comparison operators:     '__gt' (greater than), '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]). Can also count records based on a configuration of joins, useful for complex queries involving relationships.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>Optional configuration for applying joins in the count query.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The total number of records matching the filter conditions.</p> <p>Examples:</p> <p>Count users by ID: <pre><code>count = await crud.count(db, id=1)\n</code></pre></p> <p>Count users older than 30: <pre><code>count = await crud.count(db, age__gt=30)\n</code></pre></p> <p>Count users with a username other than 'admin': <pre><code>count = await crud.count(db, username__ne='admin')\n</code></pre></p> <p>Count projects with at least one participant (many-to-many relationship): <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\"\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\"\n    )\n]\ncount = await crud.count(db, joins_config=joins_config)\n</code></pre></p> <p>Count projects by a specific participant name (filter applied on a joined model): <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\"\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'name': 'Jane Doe'}\n    )\n]\ncount = await crud.count(db, joins_config=joins_config)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def count(\n    self,\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any,\n) -&gt; int:\n    \"\"\"\n    Counts records that match specified filters, supporting advanced filtering through comparison operators:\n        '__gt' (greater than), '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n    Can also count records based on a configuration of joins, useful for complex queries involving relationships.\n\n    Args:\n        db: The database session to use for the operation.\n        joins_config: Optional configuration for applying joins in the count query.\n        **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n    Returns:\n        The total number of records matching the filter conditions.\n\n    Examples:\n        Count users by ID:\n        ```python\n        count = await crud.count(db, id=1)\n        ```\n\n        Count users older than 30:\n        ```python\n        count = await crud.count(db, age__gt=30)\n        ```\n\n        Count users with a username other than 'admin':\n        ```python\n        count = await crud.count(db, username__ne='admin')\n        ```\n\n        Count projects with at least one participant (many-to-many relationship):\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\"\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\"\n            )\n        ]\n        count = await crud.count(db, joins_config=joins_config)\n        ```\n\n        Count projects by a specific participant name (filter applied on a joined model):\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\"\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'name': 'Jane Doe'}\n            )\n        ]\n        count = await crud.count(db, joins_config=joins_config)\n        ```\n    \"\"\"\n    primary_filters = self._parse_filters(**kwargs)\n\n    if joins_config is not None:\n        primary_keys = [p.name for p in _get_primary_keys(self.model)]\n        if not any(primary_keys):  # pragma: no cover\n            raise ValueError(\n                f\"The model '{self.model.__name__}' does not have a primary key defined, which is required for counting with joins.\"\n            )\n        to_select = [\n            getattr(self.model, pk).label(f\"distinct_{pk}\") for pk in primary_keys\n        ]\n        base_query = select(*to_select)\n\n        for join in joins_config:\n            join_model = join.alias or join.model\n            join_filters = (\n                self._parse_filters(model=join_model, **join.filters)\n                if join.filters\n                else []\n            )\n\n            if join.join_type == \"inner\":\n                base_query = base_query.join(join_model, join.join_on)\n            else:\n                base_query = base_query.outerjoin(join_model, join.join_on)\n\n            if join_filters:\n                base_query = base_query.where(*join_filters)\n\n        if primary_filters:\n            base_query = base_query.where(*primary_filters)\n\n        subquery = base_query.subquery()\n        count_query = select(func.count()).select_from(subquery)\n    else:\n        count_query = select(func.count()).select_from(self.model)\n        if primary_filters:\n            count_query = count_query.where(*primary_filters)\n\n    total_count: Optional[int] = await db.scalar(count_query)\n    if total_count is None:\n        raise ValueError(\"Could not find the count.\")\n\n    return total_count\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.create","title":"<code>create(db, object, commit=True)</code>  <code>async</code>","text":"<p>Create a new record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>object</code> <code>CreateSchemaType</code> <p>The Pydantic schema containing the data to be saved.</p> required <code>commit</code> <code>bool</code> <p>If True, commits the transaction immediately. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ModelType</code> <p>The created database object.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def create(\n    self, db: AsyncSession, object: CreateSchemaType, commit: bool = True\n) -&gt; ModelType:\n    \"\"\"\n    Create a new record in the database.\n\n    Args:\n        db: The SQLAlchemy async session.\n        object: The Pydantic schema containing the data to be saved.\n        commit: If True, commits the transaction immediately. Default is True.\n\n    Returns:\n        The created database object.\n    \"\"\"\n    object_dict = object.model_dump()\n    db_object: ModelType = self.model(**object_dict)\n    db.add(db_object)\n    if commit:\n        await db.commit()\n    return db_object\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.db_delete","title":"<code>db_delete(db, allow_multiple=False, commit=True, **kwargs)</code>  <code>async</code>","text":"<p>Deletes a record or multiple records from the database based on specified filters, with support for advanced filtering through comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>allow_multiple</code> <code>bool</code> <p>If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If True, commits the transaction immediately. Default is True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is False and more than one record matches the filters.</p> <p>Examples:</p> <p>Delete a user based on their ID: <pre><code>db_delete(db, id=1)\n</code></pre></p> <p>Delete users older than 30 years and allow deletion of multiple records: <pre><code>db_delete(db, allow_multiple=True, age__gt=30)\n</code></pre></p> <p>Delete a user with a specific username, ensuring only one record is deleted: <pre><code>db_delete(db, username='unique_username', allow_multiple=False)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def db_delete(\n    self,\n    db: AsyncSession,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Deletes a record or multiple records from the database based on specified filters, with support for advanced filtering through comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The database session to use for the operation.\n        allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n        commit: If True, commits the transaction immediately. Default is True.\n        **kwargs: Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n    Returns:\n        None\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n\n    Examples:\n        Delete a user based on their ID:\n        ```python\n        db_delete(db, id=1)\n        ```\n\n        Delete users older than 30 years and allow deletion of multiple records:\n        ```python\n        db_delete(db, allow_multiple=True, age__gt=30)\n        ```\n\n        Delete a user with a specific username, ensuring only one record is deleted:\n        ```python\n        db_delete(db, username='unique_username', allow_multiple=False)\n        ```\n    \"\"\"\n    if not allow_multiple and (total_count := await self.count(db, **kwargs)) &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to delete, found {total_count}.\"\n        )\n\n    filters = self._parse_filters(**kwargs)\n    stmt = delete(self.model).filter(*filters)\n    await db.execute(stmt)\n    if commit:\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.delete","title":"<code>delete(db, db_row=None, allow_multiple=False, commit=True, **kwargs)</code>  <code>async</code>","text":"<p>Soft deletes a record or optionally multiple records if it has an \"is_deleted\" attribute, otherwise performs a hard delete, based on specified filters. Supports advanced filtering through comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>db_row</code> <code>Optional[Row]</code> <p>Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.</p> <code>None</code> <code>allow_multiple</code> <code>bool</code> <p>If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If True, commits the transaction immediately. Default is True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is False and more than one record matches the filters.</p> <code>NoResultFound</code> <p>If no record matches the filters.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <p>Soft delete a specific user by ID: <pre><code>delete(db, id=1)\n</code></pre></p> <p>Hard delete users with account creation dates before 2020, allowing deletion of multiple records: <pre><code>delete(db, allow_multiple=True, creation_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Soft delete a user with a specific email, ensuring only one record is deleted: <pre><code>delete(db, email='unique@example.com', allow_multiple=False)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def delete(\n    self,\n    db: AsyncSession,\n    db_row: Optional[Row] = None,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Soft deletes a record or optionally multiple records if it has an \"is_deleted\" attribute, otherwise performs a hard delete, based on specified filters.\n    Supports advanced filtering through comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The database session to use for the operation.\n        db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n        allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n        commit: If True, commits the transaction immediately. Default is True.\n        **kwargs: Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n        NoResultFound: If no record matches the filters.\n\n    Returns:\n        None\n\n    Examples:\n        Soft delete a specific user by ID:\n        ```python\n        delete(db, id=1)\n        ```\n\n        Hard delete users with account creation dates before 2020, allowing deletion of multiple records:\n        ```python\n        delete(db, allow_multiple=True, creation_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Soft delete a user with a specific email, ensuring only one record is deleted:\n        ```python\n        delete(db, email='unique@example.com', allow_multiple=False)\n        ```\n    \"\"\"\n    filters = self._parse_filters(**kwargs)\n    if db_row:\n        if hasattr(db_row, self.is_deleted_column) and hasattr(\n            db_row, self.deleted_at_column\n        ):\n            setattr(db_row, self.is_deleted_column, True)\n            setattr(db_row, self.deleted_at_column, datetime.now(timezone.utc))\n            if commit:\n                await db.commit()\n        else:\n            await db.delete(db_row)\n        if commit:\n            await db.commit()\n        return\n\n    total_count = await self.count(db, **kwargs)\n    if total_count == 0:\n        raise NoResultFound(\"No record found to delete.\")\n    if not allow_multiple and total_count &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to delete, found {total_count}.\"\n        )\n\n    if self.is_deleted_column in self.model_col_names:\n        update_stmt = (\n            update(self.model)\n            .filter(*filters)\n            .values(is_deleted=True, deleted_at=datetime.now(timezone.utc))\n        )\n        await db.execute(update_stmt)\n    else:\n        delete_stmt = delete(self.model).filter(*filters)\n        await db.execute(delete_stmt)\n\n    if commit:\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.exists","title":"<code>exists(db, **kwargs)</code>  <code>async</code>","text":"<p>Checks if any records exist that match the given filter conditions. This method supports advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one record matches the filter conditions, False otherwise.</p> <p>Examples:</p> <p>Fetch a user by ID exists: <pre><code>exists = await crud.exists(db, id=1)\n</code></pre></p> <p>Check if any user is older than 30: <pre><code>exists = await crud.exists(db, age__gt=30)\n</code></pre></p> <p>Check if any user registered before Jan 1, 2020: <pre><code>exists = await crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Check if a username other than 'admin' exists: <pre><code>exists = await crud.exists(db, username__ne='admin')\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n    \"\"\"\n    Checks if any records exist that match the given filter conditions.\n    This method supports advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The database session to use for the operation.\n        **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n    Returns:\n        True if at least one record matches the filter conditions, False otherwise.\n\n    Examples:\n        Fetch a user by ID exists:\n        ```python\n        exists = await crud.exists(db, id=1)\n        ```\n\n        Check if any user is older than 30:\n        ```python\n        exists = await crud.exists(db, age__gt=30)\n        ```\n\n        Check if any user registered before Jan 1, 2020:\n        ```python\n        exists = await crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Check if a username other than 'admin' exists:\n        ```python\n        exists = await crud.exists(db, username__ne='admin')\n        ```\n    \"\"\"\n    filters = self._parse_filters(**kwargs)\n    stmt = select(self.model).filter(*filters).limit(1)\n\n    result = await db.execute(stmt)\n    return result.first() is not None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get","title":"<code>get(db, schema_to_select=None, return_as_model=False, one_or_none=False, **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record based on specified filters. This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks. Supported operators include:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Optional Pydantic schema for selecting specific columns.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.</p> <code>False</code> <code>one_or_none</code> <code>bool</code> <p>Flag to get strictly one or no result. Multiple results are not allowed.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If return_as_model is True but schema_to_select is not provided.</p> <p>Returns:</p> Type Description <code>Optional[Union[dict, BaseModel]]</code> <p>A dictionary or a Pydantic model instance of the fetched database row, or None if no match is found.</p> <p>Examples:</p> <p>Fetch a user by ID: <pre><code>user = await crud.get(db, id=1)\n</code></pre></p> <p>Fetch a user with an age greater than 30: <pre><code>user = await crud.get(db, age__gt=30)\n</code></pre></p> <p>Fetch a user with a registration date before Jan 1, 2020: <pre><code>user = await crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Fetch a user not equal to a specific username: <pre><code>user = await crud.get(db, username__ne='admin')\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, BaseModel]]:\n    \"\"\"\n    Fetches a single record based on specified filters.\n    This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n    Supported operators include:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The database session to use for the operation.\n        schema_to_select: Optional Pydantic schema for selecting specific columns.\n        return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n        one_or_none: Flag to get strictly one or no result. Multiple results are not allowed.\n        **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n    Raises:\n        ValueError: If return_as_model is True but schema_to_select is not provided.\n\n    Returns:\n        A dictionary or a Pydantic model instance of the fetched database row, or None if no match is found.\n\n    Examples:\n        Fetch a user by ID:\n        ```python\n        user = await crud.get(db, id=1)\n        ```\n\n        Fetch a user with an age greater than 30:\n        ```python\n        user = await crud.get(db, age__gt=30)\n        ```\n\n        Fetch a user with a registration date before Jan 1, 2020:\n        ```python\n        user = await crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Fetch a user not equal to a specific username:\n        ```python\n        user = await crud.get(db, username__ne='admin')\n        ```\n    \"\"\"\n    stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n    db_row = await db.execute(stmt)\n    result: Optional[Row] = db_row.one_or_none() if one_or_none else db_row.first()\n    if result is None:\n        return None\n    out: dict = dict(result._mapping)\n    if not return_as_model:\n        return out\n    if not schema_to_select:\n        raise ValueError(\n            \"schema_to_select must be provided when return_as_model is True.\"\n        )\n    return schema_to_select(**out)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_joined","title":"<code>get_joined(db, schema_to_select=None, join_model=None, join_on=None, join_prefix=None, join_schema_to_select=None, join_type='left', alias=None, join_filters=None, joins_config=None, nest_joins=False, relationship_type=None, **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record with one or multiple joins on other models. If 'join_on' is not provided, the method attempts to automatically detect the join condition using foreign key relationships. For multiple joins, use 'joins_config' to specify each join configuration. Advanced filters supported:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_model</code> <code>Optional[type[DeclarativeBase]]</code> <p>The model to join with.</p> <code>None</code> <code>join_on</code> <code>Optional[Union[Join, BinaryExpression]]</code> <p>SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If None, no prefix is added.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.</p> <code>'left'</code> <code>alias</code> <code>Optional[AliasedClass]</code> <p>An instance of <code>AliasedClass</code> for the join model, useful for self-joins or multiple joins on the same model. Result of <code>aliased(join_model)</code>.</p> <code>None</code> <code>join_filters</code> <code>Optional[dict]</code> <p>Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.</p> <code>None</code> <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>A list of JoinConfig instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.</p> <code>None</code> <code>nest_joins</code> <code>bool</code> <p>If True, nested data structures will be returned where joined model data are nested under the join_prefix as a dictionary.</p> <code>False</code> <code>relationship_type</code> <code>Optional[str]</code> <p>Specifies the relationship type, such as 'one-to-one' or 'one-to-many'. Used to determine how to nest the joined data. If None, uses one-to-one.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>A dictionary representing the joined record, or None if no record matches the criteria.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both single join parameters and 'joins_config' are used simultaneously.</p> <code>ArgumentError</code> <p>If any provided model in 'joins_config' is not recognized or invalid.</p> <code>NoResultFound</code> <p>If no record matches the criteria with the provided filters.</p> <p>Examples:</p> <p>Simple example: Joining User and Tier models without explicitly providing join_on <pre><code>result = await crud_user.get_joined(\n    db=session,\n    join_model=Tier,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema\n)\n</code></pre></p> <p>Fetch a user and their associated tier, filtering by user ID: <pre><code>get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, id=1)\n</code></pre></p> <p>Fetch a user and their associated tier, where the user's age is greater than 30: <pre><code>get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, age__gt=30)\n</code></pre></p> <p>Fetch a user and their associated tier, excluding users with the 'admin' username: <pre><code>get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, username__ne='admin')\n</code></pre></p> <p>Complex example: Joining with a custom join condition, additional filter parameters, and a prefix <pre><code>from sqlalchemy import and_\nresult = await crud_user.get_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    username=\"john_doe\"\n)\n</code></pre></p> <p>Example of using 'joins_config' for multiple joins: <pre><code>from fastcrud import JoinConfig\n\nresult = await crud_user.get_joined(\n    db=session,\n    schema_to_select=UserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=TierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=DepartmentSchema,\n            join_type=\"inner\",\n        )\n    ]\n)\n</code></pre></p> <p>Using <code>alias</code> for joining the same model multiple times: <pre><code>from fastcrud import aliased\n\nowner_alias = aliased(ModelTest, name=\"owner\")\nuser_alias = aliased(ModelTest, name=\"user\")\n\nresult = await crud.get_joined(\n    db=session,\n    schema_to_select=BookingSchema,\n    joins_config=[\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.owner_id == owner_alias.id,\n            join_prefix=\"owner_\",\n            alias=owner_alias,\n            schema_to_select=UserSchema\n        ),\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.user_id == user_alias.id,\n            join_prefix=\"user_\",\n            alias=user_alias,\n            schema_to_select=UserSchema\n        )\n    ],\n    id=1\n)\n</code></pre></p> <p>Fetching a single project and its associated participants where a participant has a specific role: <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\"\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'role': 'Designer'}\n    )\n]\nproject = await crud.get_joined(\n    db=session,\n    schema_to_select=ProjectSchema,\n    joins_config=joins_config\n)\n</code></pre></p> <p>Example of using 'joins_config' for multiple joins with nested joins enabled: <pre><code>from fastcrud import JoinConfig\n\nresult = await crud_user.get_joined(\n    db=session,\n    schema_to_select=UserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=TierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=DepartmentSchema,\n            join_type=\"inner\",\n        )\n    ],\n    nest_joins=True\n)\n# Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n</code></pre></p> <p>Example using one-to-one relationship: <pre><code>result = await crud_user.get_joined(\n    db=session,\n    join_model=Profile,\n    join_on=User.profile_id == Profile.id,\n    schema_to_select=UserSchema,\n    join_schema_to_select=ProfileSchema,\n    relationship_type='one-to-one' # note that this is the default behavior\n)\n# Expect 'result' to have 'profile' as a nested dictionary\n</code></pre></p> <p>Example using one-to-many relationship: ```python result = await crud_user.get_joined(     db=session,     join_model=Post,     join_on=User.id == Post.user_id,     schema_to_select=UserSchema,     join_schema_to_select=PostSchema,     relationship_type='one-to-many',     nest_joins=True )</p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_joined--expect-result-to-have-posts-as-a-nested-list-of-dictionaries","title":"Expect 'result' to have 'posts' as a nested list of dictionaries","text":"Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_joined(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_model: Optional[type[DeclarativeBase]] = None,\n    join_on: Optional[Union[Join, BinaryExpression]] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass] = None,\n    join_filters: Optional[dict] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    nest_joins: bool = False,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"\n    Fetches a single record with one or multiple joins on other models. If 'join_on' is not provided, the method attempts\n    to automatically detect the join condition using foreign key relationships. For multiple joins, use 'joins_config' to\n    specify each join configuration. Advanced filters supported:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The SQLAlchemy async session.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_model: The model to join with.\n        join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n        alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n        join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n        joins_config: A list of JoinConfig instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.\n        nest_joins: If True, nested data structures will be returned where joined model data are nested under the join_prefix as a dictionary.\n        relationship_type: Specifies the relationship type, such as 'one-to-one' or 'one-to-many'. Used to determine how to nest the joined data. If None, uses one-to-one.\n        **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary representing the joined record, or None if no record matches the criteria.\n\n    Raises:\n        ValueError: If both single join parameters and 'joins_config' are used simultaneously.\n        ArgumentError: If any provided model in 'joins_config' is not recognized or invalid.\n        NoResultFound: If no record matches the criteria with the provided filters.\n\n    Examples:\n        Simple example: Joining User and Tier models without explicitly providing join_on\n        ```python\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Tier,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema\n        )\n        ```\n\n        Fetch a user and their associated tier, filtering by user ID:\n        ```python\n        get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, id=1)\n        ```\n\n        Fetch a user and their associated tier, where the user's age is greater than 30:\n        ```python\n        get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, age__gt=30)\n        ```\n\n        Fetch a user and their associated tier, excluding users with the 'admin' username:\n        ```python\n        get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, username__ne='admin')\n        ```\n\n        Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n        ```python\n        from sqlalchemy import and_\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            username=\"john_doe\"\n        )\n        ```\n\n        Example of using 'joins_config' for multiple joins:\n        ```python\n        from fastcrud import JoinConfig\n\n        result = await crud_user.get_joined(\n            db=session,\n            schema_to_select=UserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=TierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=DepartmentSchema,\n                    join_type=\"inner\",\n                )\n            ]\n        )\n        ```\n\n        Using `alias` for joining the same model multiple times:\n        ```python\n        from fastcrud import aliased\n\n        owner_alias = aliased(ModelTest, name=\"owner\")\n        user_alias = aliased(ModelTest, name=\"user\")\n\n        result = await crud.get_joined(\n            db=session,\n            schema_to_select=BookingSchema,\n            joins_config=[\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.owner_id == owner_alias.id,\n                    join_prefix=\"owner_\",\n                    alias=owner_alias,\n                    schema_to_select=UserSchema\n                ),\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.user_id == user_alias.id,\n                    join_prefix=\"user_\",\n                    alias=user_alias,\n                    schema_to_select=UserSchema\n                )\n            ],\n            id=1\n        )\n        ```\n\n        Fetching a single project and its associated participants where a participant has a specific role:\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\"\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'role': 'Designer'}\n            )\n        ]\n        project = await crud.get_joined(\n            db=session,\n            schema_to_select=ProjectSchema,\n            joins_config=joins_config\n        )\n        ```\n\n        Example of using 'joins_config' for multiple joins with nested joins enabled:\n        ```python\n        from fastcrud import JoinConfig\n\n        result = await crud_user.get_joined(\n            db=session,\n            schema_to_select=UserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=TierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=DepartmentSchema,\n                    join_type=\"inner\",\n                )\n            ],\n            nest_joins=True\n        )\n        # Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n        ```\n\n        Example using one-to-one relationship:\n        ```python\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Profile,\n            join_on=User.profile_id == Profile.id,\n            schema_to_select=UserSchema,\n            join_schema_to_select=ProfileSchema,\n            relationship_type='one-to-one' # note that this is the default behavior\n        )\n        # Expect 'result' to have 'profile' as a nested dictionary\n        ```\n\n        Example using one-to-many relationship:\n        ```python\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Post,\n            join_on=User.id == Post.user_id,\n            schema_to_select=UserSchema,\n            join_schema_to_select=PostSchema,\n            relationship_type='one-to-many',\n            nest_joins=True\n        )\n        # Expect 'result' to have 'posts' as a nested list of dictionaries\n    \"\"\"\n    if joins_config and (\n        join_model or join_prefix or join_on or join_schema_to_select or alias\n    ):\n        raise ValueError(\n            \"Cannot use both single join parameters and joins_config simultaneously.\"\n        )\n    elif not joins_config and not join_model:\n        raise ValueError(\"You need one of join_model or joins_config.\")\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model,\n        schema=schema_to_select,\n    )\n    stmt: Select = select(*primary_select).select_from(self.model)\n\n    join_definitions = joins_config if joins_config else []\n    if join_model:\n        join_definitions.append(\n            JoinConfig(\n                model=join_model,\n                join_on=join_on,\n                join_prefix=join_prefix,\n                schema_to_select=join_schema_to_select,\n                join_type=join_type,\n                alias=alias,\n                filters=join_filters,\n                relationship_type=relationship_type,\n            )\n        )\n\n    stmt = self._prepare_and_apply_joins(\n        stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n    )\n    primary_filters = self._parse_filters(**kwargs)\n    if primary_filters:\n        stmt = stmt.filter(*primary_filters)\n\n    db_rows = await db.execute(stmt)\n    if any(join.relationship_type == \"one-to-many\" for join in join_definitions):\n        if nest_joins is False:  # pragma: no cover\n            raise ValueError(\n                \"Cannot use one-to-many relationship with nest_joins=False\"\n            )\n        results = db_rows.fetchall()\n        data_list = [dict(row._mapping) for row in results]\n    else:\n        result = db_rows.first()\n        if result is not None:\n            data_list = [dict(result._mapping)]\n        else:\n            data_list = []\n\n    if data_list:\n        if nest_joins:\n            nested_data: dict = {}\n            for data in data_list:\n                nested_data = _nest_join_data(\n                    data,\n                    join_definitions,\n                    nested_data=nested_data,\n                )\n            return nested_data\n        return data_list[0]\n\n    return None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi","title":"<code>get_multi(db, offset=0, limit=100, schema_to_select=None, sort_columns=None, sort_orders=None, return_as_model=False, return_total_count=True, **kwargs)</code>  <code>async</code>","text":"<p>Fetches multiple records based on filters, supporting sorting, pagination, and advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>offset</code> <code>int</code> <p>Starting index for records to fetch, useful for pagination.</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to fetch in one call. Use <code>None</code> for \"no limit\", fetching all matching rows. Note that in order to use <code>limit=None</code>, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Optional Pydantic schema for selecting specific columns. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>Column names to sort the results by.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>Corresponding sort orders ('asc', 'desc') for each column in sort_columns.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, returns data as instances of the specified Pydantic model.</p> <code>False</code> <code>return_total_count</code> <code>bool</code> <p>If True, also returns the total count of rows with the selected filters. Useful for pagination.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for more detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing 'data' with fetched records and 'total_count' indicating the total number of records matching the filters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit or offset is negative, or if schema_to_select is required but not provided or invalid.</p> <p>Examples:</p> <p>Fetch the first 10 users: <pre><code>users = await crud.get_multi(db, 0, 10)\n</code></pre></p> <p>Fetch next 10 users with sorted by username: <pre><code>users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n</code></pre></p> <p>Fetch 10 users older than 30, sorted by age in descending order: <pre><code>get_multi(db, offset=0, limit=10, age__gt=30, sort_columns='age', sort_orders='desc')\n</code></pre></p> <p>Fetch 10 users with a registration date before Jan 1, 2020: <pre><code>get_multi(db, offset=0, limit=10, registration_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Fetch 10 users with a username other than 'admin', returning as model instances (ensure appropriate schema is passed): <pre><code>get_multi(db, offset=0, limit=10, username__ne='admin', schema_to_select=UserSchema, return_as_model=True)\n</code></pre></p> <p>Fetch users with filtering and multiple column sorting: <pre><code>users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi(\n    self,\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetches multiple records based on filters, supporting sorting, pagination, and advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The database session to use for the operation.\n        offset: Starting index for records to fetch, useful for pagination.\n        limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n        sort_columns: Column names to sort the results by.\n        sort_orders: Corresponding sort orders ('asc', 'desc') for each column in sort_columns.\n        return_as_model: If True, returns data as instances of the specified Pydantic model.\n        return_total_count: If True, also returns the total count of rows with the selected filters. Useful for pagination.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n    Returns:\n        A dictionary containing 'data' with fetched records and 'total_count' indicating the total number of records matching the filters.\n\n    Raises:\n        ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n    Examples:\n        Fetch the first 10 users:\n        ```python\n        users = await crud.get_multi(db, 0, 10)\n        ```\n\n        Fetch next 10 users with sorted by username:\n        ```python\n        users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n        ```\n\n        Fetch 10 users older than 30, sorted by age in descending order:\n        ```python\n        get_multi(db, offset=0, limit=10, age__gt=30, sort_columns='age', sort_orders='desc')\n        ```\n\n        Fetch 10 users with a registration date before Jan 1, 2020:\n        ```python\n        get_multi(db, offset=0, limit=10, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Fetch 10 users with a username other than 'admin', returning as model instances (ensure appropriate schema is passed):\n        ```python\n        get_multi(db, offset=0, limit=10, username__ne='admin', schema_to_select=UserSchema, return_as_model=True)\n        ```\n\n        Fetch users with filtering and multiple column sorting:\n        ```python\n        users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n        ```\n    \"\"\"\n    if (limit is not None and limit &lt; 0) or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    stmt = await self.select(\n        schema_to_select=schema_to_select,\n        sort_columns=sort_columns,\n        sort_orders=sort_orders,\n        **kwargs,\n    )\n\n    if offset:\n        stmt = stmt.offset(offset)\n    if limit is not None:\n        stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    response: dict[str, Any] = {\"data\": data}\n\n    if return_total_count:\n        total_count = await self.count(db=db, **kwargs)\n        response[\"total_count\"] = total_count\n\n    if return_as_model:\n        if not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        try:\n            model_data = [schema_to_select(**row) for row in data]\n            response[\"data\"] = model_data\n        except ValidationError as e:\n            raise ValueError(\n                f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n            )\n\n    return response\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_by_cursor","title":"<code>get_multi_by_cursor(db, cursor=None, limit=100, schema_to_select=None, sort_column='id', sort_order='asc', **kwargs)</code>  <code>async</code>","text":"<p>Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling. It supports advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>cursor</code> <code>Any</code> <p>The cursor value to start fetching records from. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of rows to fetch.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns.</p> <code>None</code> <code>sort_column</code> <code>str</code> <p>Column name to use for sorting and cursor pagination.</p> <code>'id'</code> <code>sort_order</code> <code>str</code> <p>Sorting direction, either 'asc' or 'desc'.</p> <code>'asc'</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.</p> <p>Examples:</p> <p>Fetch the first set of records (e.g., the first page in an infinite scrolling scenario) <pre><code>first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\nFetch the next set of records using the cursor from the first page\nnext_cursor = first_page['next_cursor']\nsecond_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n</code></pre></p> <p>Fetch records with age greater than 30 using cursor-based pagination: <pre><code>get_multi_by_cursor(db, limit=10, sort_column='age', sort_order='asc', age__gt=30)\n</code></pre></p> <p>Fetch records excluding a specific username using cursor-based pagination: <pre><code>get_multi_by_cursor(db, limit=10, sort_column='username', sort_order='asc', username__ne='admin')\n</code></pre></p> Note <p>This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features. Make sure the column used for cursor pagination is indexed for performance. This method assumes that your records can be ordered by a unique, sequential field (like <code>id</code> or <code>created_at</code>).</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_by_cursor(\n    self,\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n    It supports advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The SQLAlchemy async session.\n        cursor: The cursor value to start fetching records from. Defaults to None.\n        limit: Maximum number of rows to fetch.\n        schema_to_select: Pydantic schema for selecting specific columns.\n        sort_column: Column name to use for sorting and cursor pagination.\n        sort_order: Sorting direction, either 'asc' or 'desc'.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n    Returns:\n        A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.\n\n    Examples:\n        Fetch the first set of records (e.g., the first page in an infinite scrolling scenario)\n        ```python\n        first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\n        Fetch the next set of records using the cursor from the first page\n        next_cursor = first_page['next_cursor']\n        second_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n        ```\n\n        Fetch records with age greater than 30 using cursor-based pagination:\n        ```python\n        get_multi_by_cursor(db, limit=10, sort_column='age', sort_order='asc', age__gt=30)\n        ```\n\n        Fetch records excluding a specific username using cursor-based pagination:\n        ```python\n        get_multi_by_cursor(db, limit=10, sort_column='username', sort_order='asc', username__ne='admin')\n        ```\n\n    Note:\n        This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n        Make sure the column used for cursor pagination is indexed for performance.\n        This method assumes that your records can be ordered by a unique, sequential field (like `id` or `created_at`).\n    \"\"\"\n    if limit == 0:\n        return {\"data\": [], \"next_cursor\": None}\n\n    stmt = await self.select(\n        schema_to_select=schema_to_select,\n        **kwargs,\n    )\n\n    if cursor:\n        if sort_order == \"asc\":\n            stmt = stmt.filter(getattr(self.model, sort_column) &gt; cursor)\n        else:\n            stmt = stmt.filter(getattr(self.model, sort_column) &lt; cursor)\n\n    stmt = stmt.order_by(\n        asc(getattr(self.model, sort_column))\n        if sort_order == \"asc\"\n        else desc(getattr(self.model, sort_column))\n    )\n    stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    next_cursor = None\n    if len(data) == limit:\n        if sort_order == \"asc\":\n            next_cursor = data[-1][sort_column]\n        else:\n            data[0][sort_column]\n\n    return {\"data\": data, \"next_cursor\": next_cursor}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_joined","title":"<code>get_multi_joined(db, schema_to_select=None, join_model=None, join_on=None, join_prefix=None, join_schema_to_select=None, join_type='left', alias=None, join_filters=None, nest_joins=False, offset=0, limit=100, sort_columns=None, sort_orders=None, return_as_model=False, joins_config=None, return_total_count=True, relationship_type=None, **kwargs)</code>  <code>async</code>","text":"<p>Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion, supporting advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_model</code> <code>Optional[type[ModelType]]</code> <p>The model to join with.</p> <code>None</code> <code>join_on</code> <code>Optional[Any]</code> <p>SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If None, no prefix is added.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.</p> <code>'left'</code> <code>alias</code> <code>Optional[AliasedClass[Any]]</code> <p>An instance of <code>AliasedClass</code> for the join model, useful for self-joins or multiple joins on the same model. Result of <code>aliased(join_model)</code>.</p> <code>None</code> <code>join_filters</code> <code>Optional[dict]</code> <p>Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.</p> <code>None</code> <code>nest_joins</code> <code>bool</code> <p>If True, nested data structures will be returned where joined model data are nested under the join_prefix as a dictionary.</p> <code>False</code> <code>offset</code> <code>int</code> <p>The offset (number of records to skip) for pagination.</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to fetch in one call. Use <code>None</code> for \"no limit\", fetching all matching rows. Note that in order to use <code>limit=None</code>, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.</p> <code>100</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or a list of column names on which to apply sorting.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.</p> <code>False</code> <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>List of JoinConfig instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.</p> <code>None</code> <code>return_total_count</code> <code>bool</code> <p>If True, also returns the total count of rows with the selected filters. Useful for pagination.</p> <code>True</code> <code>relationship_type</code> <code>Optional[str]</code> <p>Specifies the relationship type, such as 'one-to-one' or 'one-to-many'. Used to determine how to nest the joined data. If None, uses one-to-one.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary query, including advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit or offset is negative, or if schema_to_select is required but not provided or invalid.         Also if both 'joins_config' and any of the single join parameters are provided or none of 'joins_config' and 'join_model' is provided.</p> <p>Examples:</p> <p>Fetching multiple User records joined with Tier records, using left join, returning raw data: <pre><code>users = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    offset=0,\n    limit=10\n)\n</code></pre></p> <p>Fetch users joined with their tiers, sorted by username, where user's age is greater than 30: <pre><code>users = get_multi_joined(\n    db,\n    User,\n    Tier,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    age__gt=30,\n    sort_columns='username',\n    sort_orders='asc'\n)\n</code></pre></p> <p>Fetch users joined with their tiers, excluding users with 'admin' username, returning as model instances: <pre><code>users = get_multi_joined(\n    db,\n    User,\n    Tier,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    username__ne='admin',\n    return_as_model=True\n)\n</code></pre></p> <p>Fetching and sorting by username in descending order, returning as Pydantic model: <pre><code>users = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    offset=0,\n    limit=10,\n    sort_columns=['username'],\n    sort_orders=['desc'],\n    return_as_model=True\n)\n</code></pre></p> <p>Fetching with complex conditions and custom join, returning as Pydantic model: <pre><code>users = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_on=User.tier_id == Tier.id,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    offset=0,\n    limit=10,\n    is_active=True,\n    return_as_model=True\n)\n</code></pre></p> <p>Example using 'joins_config' for multiple joins: <pre><code>from fastcrud import JoinConfig\n\nusers = await crud_user.get_multi_joined(\n    db=session,\n    schema_to_select=UserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=TierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=DepartmentSchema,\n            join_type=\"inner\",\n        )\n    ],\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc'\n)\n</code></pre></p> <p>Example using <code>alias</code> for multiple joins, with pagination, sorting, and model conversion: <pre><code>from fastcrud import JoinConfig, FastCRUD, aliased\n\n# Aliasing for self-joins or multiple joins on the same table\nowner_alias = aliased(ModelTest, name=\"owner\")\nuser_alias = aliased(ModelTest, name=\"user\")\n\n# Initialize your FastCRUD instance for BookingModel\ncrud = FastCRUD(BookingModel)\n\nresult = await crud.get_multi_joined(\n    db=session,\n    schema_to_select=BookingSchema,  # Primary model schema\n    joins_config=[\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.owner_id == owner_alias.id,\n            join_prefix=\"owner_\",\n            alias=owner_alias,\n            schema_to_select=UserSchema  # Schema for the joined model\n        ),\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.user_id == user_alias.id,\n            join_prefix=\"user_\",\n            alias=user_alias,\n            schema_to_select=UserSchema\n        )\n    ],\n    offset=10,  # Skip the first 10 records\n    limit=5,  # Fetch up to 5 records\n    sort_columns=['booking_date'],  # Sort by booking_date\n    sort_orders=['desc']  # In descending order\n)\n</code></pre></p> <p>Fetching multiple project records and their associated participants where participants have a specific role: <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\"\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'role': 'Developer'}\n    )\n]\nprojects = await crud.get_multi_joined(\n    db=session,\n    schema_to_select=ProjectSchema,\n    joins_config=joins_config,\n    limit=10\n)\n</code></pre></p> <p>Fetching a list of projects, each with nested details of associated tasks and task creators, using nested joins: ```python projects = await crud.get_multi_joined(     db=session,     schema_to_select=ProjectSchema,     joins_config=[         JoinConfig(             model=Task,             join_on=Project.id == Task.project_id,             join_prefix=\"task_\",             schema_to_select=TaskSchema,             join_type=\"left\",         ),         JoinConfig(             model=User,             join_on=Task.creator_id == User.id,             join_prefix=\"creator_\",             schema_to_select=UserSchema,             join_type=\"left\",             alias=aliased(User, name=\"task_creator\")         )     ],     nest_joins=True,     offset=0,     limit=5,     sort_columns='project_name',     sort_orders='asc' )</p> <pre><code>Example using one-to-one relationship:\n```python\nusers = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Profile,\n    join_on=User.profile_id == Profile.id,\n    schema_to_select=UserSchema,\n    join_schema_to_select=ProfileSchema,\n    relationship_type='one-to-one', # note that this is the default behavior\n    offset=0,\n    limit=10\n)\n# Expect 'profile' to be nested as a dictionary under each user\n</code></pre> <p>Example using one-to-many relationship: <pre><code>users = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Post,\n    join_on=User.id == Post.user_id,\n    schema_to_select=UserSchema,\n    join_schema_to_select=PostSchema,\n    relationship_type='one-to-many',\n    nest_joins=True,\n    offset=0,\n    limit=10\n)\n# Expect 'posts' to be nested as a list of dictionaries under each user\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_joined(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    joins_config: Optional[list[JoinConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion,\n    supporting advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The SQLAlchemy async session.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_model: The model to join with.\n        join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n        alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n        join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n        nest_joins: If True, nested data structures will be returned where joined model data are nested under the join_prefix as a dictionary.\n        offset: The offset (number of records to skip) for pagination.\n        limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n        sort_columns: A single column name or a list of column names on which to apply sorting.\n        sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n        return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n        joins_config: List of JoinConfig instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.\n        return_total_count: If True, also returns the total count of rows with the selected filters. Useful for pagination.\n        relationship_type: Specifies the relationship type, such as 'one-to-one' or 'one-to-many'. Used to determine how to nest the joined data. If None, uses one-to-one.\n        **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n    Raises:\n        ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n                    Also if both 'joins_config' and any of the single join parameters are provided or none of 'joins_config' and 'join_model' is provided.\n\n    Examples:\n        Fetching multiple User records joined with Tier records, using left join, returning raw data:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            offset=0,\n            limit=10\n        )\n        ```\n\n        Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n        ```python\n        users = get_multi_joined(\n            db,\n            User,\n            Tier,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            age__gt=30,\n            sort_columns='username',\n            sort_orders='asc'\n        )\n        ```\n\n        Fetch users joined with their tiers, excluding users with 'admin' username, returning as model instances:\n        ```python\n        users = get_multi_joined(\n            db,\n            User,\n            Tier,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            username__ne='admin',\n            return_as_model=True\n        )\n        ```\n\n        Fetching and sorting by username in descending order, returning as Pydantic model:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            offset=0,\n            limit=10,\n            sort_columns=['username'],\n            sort_orders=['desc'],\n            return_as_model=True\n        )\n        ```\n\n        Fetching with complex conditions and custom join, returning as Pydantic model:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_on=User.tier_id == Tier.id,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            offset=0,\n            limit=10,\n            is_active=True,\n            return_as_model=True\n        )\n        ```\n\n        Example using 'joins_config' for multiple joins:\n        ```python\n        from fastcrud import JoinConfig\n\n        users = await crud_user.get_multi_joined(\n            db=session,\n            schema_to_select=UserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=TierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=DepartmentSchema,\n                    join_type=\"inner\",\n                )\n            ],\n            offset=0,\n            limit=10,\n            sort_columns='username',\n            sort_orders='asc'\n        )\n        ```\n\n        Example using `alias` for multiple joins, with pagination, sorting, and model conversion:\n        ```python\n        from fastcrud import JoinConfig, FastCRUD, aliased\n\n        # Aliasing for self-joins or multiple joins on the same table\n        owner_alias = aliased(ModelTest, name=\"owner\")\n        user_alias = aliased(ModelTest, name=\"user\")\n\n        # Initialize your FastCRUD instance for BookingModel\n        crud = FastCRUD(BookingModel)\n\n        result = await crud.get_multi_joined(\n            db=session,\n            schema_to_select=BookingSchema,  # Primary model schema\n            joins_config=[\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.owner_id == owner_alias.id,\n                    join_prefix=\"owner_\",\n                    alias=owner_alias,\n                    schema_to_select=UserSchema  # Schema for the joined model\n                ),\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.user_id == user_alias.id,\n                    join_prefix=\"user_\",\n                    alias=user_alias,\n                    schema_to_select=UserSchema\n                )\n            ],\n            offset=10,  # Skip the first 10 records\n            limit=5,  # Fetch up to 5 records\n            sort_columns=['booking_date'],  # Sort by booking_date\n            sort_orders=['desc']  # In descending order\n        )\n        ```\n\n        Fetching multiple project records and their associated participants where participants have a specific role:\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\"\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'role': 'Developer'}\n            )\n        ]\n        projects = await crud.get_multi_joined(\n            db=session,\n            schema_to_select=ProjectSchema,\n            joins_config=joins_config,\n            limit=10\n        )\n        ```\n\n        Fetching a list of projects, each with nested details of associated tasks and task creators, using nested joins:\n        ```python\n        projects = await crud.get_multi_joined(\n            db=session,\n            schema_to_select=ProjectSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Task,\n                    join_on=Project.id == Task.project_id,\n                    join_prefix=\"task_\",\n                    schema_to_select=TaskSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=User,\n                    join_on=Task.creator_id == User.id,\n                    join_prefix=\"creator_\",\n                    schema_to_select=UserSchema,\n                    join_type=\"left\",\n                    alias=aliased(User, name=\"task_creator\")\n                )\n            ],\n            nest_joins=True,\n            offset=0,\n            limit=5,\n            sort_columns='project_name',\n            sort_orders='asc'\n        )\n    ```\n\n    Example using one-to-one relationship:\n    ```python\n    users = await crud_user.get_multi_joined(\n        db=session,\n        join_model=Profile,\n        join_on=User.profile_id == Profile.id,\n        schema_to_select=UserSchema,\n        join_schema_to_select=ProfileSchema,\n        relationship_type='one-to-one', # note that this is the default behavior\n        offset=0,\n        limit=10\n    )\n    # Expect 'profile' to be nested as a dictionary under each user\n    ```\n\n    Example using one-to-many relationship:\n    ```python\n    users = await crud_user.get_multi_joined(\n        db=session,\n        join_model=Post,\n        join_on=User.id == Post.user_id,\n        schema_to_select=UserSchema,\n        join_schema_to_select=PostSchema,\n        relationship_type='one-to-many',\n        nest_joins=True,\n        offset=0,\n        limit=10\n    )\n    # Expect 'posts' to be nested as a list of dictionaries under each user\n    ```\n    \"\"\"\n    if joins_config and (\n        join_model\n        or join_prefix\n        or join_on\n        or join_schema_to_select\n        or alias\n        or relationship_type\n    ):\n        raise ValueError(\n            \"Cannot use both single join parameters and joins_config simultaneously.\"\n        )\n    elif not joins_config and not join_model:\n        raise ValueError(\"You need one of join_model or joins_config.\")\n\n    if (limit is not None and limit &lt; 0) or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    stmt: Select = select(*primary_select)\n\n    join_definitions = joins_config if joins_config else []\n    if join_model:\n        join_definitions.append(\n            JoinConfig(\n                model=join_model,\n                join_on=join_on\n                or _auto_detect_join_condition(self.model, join_model),\n                join_prefix=join_prefix,\n                schema_to_select=join_schema_to_select,\n                join_type=join_type,\n                alias=alias,\n                filters=join_filters,\n                relationship_type=relationship_type,\n            )\n        )\n\n    stmt = self._prepare_and_apply_joins(\n        stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n    )\n\n    primary_filters = self._parse_filters(**kwargs)\n    if primary_filters:\n        stmt = stmt.filter(*primary_filters)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n    if offset:\n        stmt = stmt.offset(offset)\n    if limit is not None:\n        stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data: list[Union[dict, BaseModel]] = []\n\n    for row in result.mappings().all():\n        row_dict = dict(row)\n\n        if nest_joins:\n            row_dict = _nest_join_data(\n                data=row_dict,\n                join_definitions=join_definitions,\n            )\n\n        if return_as_model:\n            if schema_to_select is None:\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            try:\n                model_instance = schema_to_select(**row_dict)\n                data.append(model_instance)\n            except ValidationError as e:\n                raise ValueError(\n                    f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                )\n        else:\n            data.append(row_dict)\n\n    if nest_joins and any(\n        join.relationship_type == \"one-to-many\" for join in join_definitions\n    ):\n        nested_data = _nest_multi_join_data(\n            base_primary_key=self._primary_keys[0].name,\n            data=data,\n            joins_config=join_definitions,\n            return_as_model=return_as_model,\n            schema_to_select=schema_to_select if return_as_model else None,\n            nested_schema_to_select={\n                (\n                    join.join_prefix.rstrip(\"_\")\n                    if join.join_prefix\n                    else join.model.__name__\n                ): join.schema_to_select\n                for join in join_definitions\n                if join.schema_to_select\n            },\n        )\n    else:\n        nested_data = data\n\n    response: dict[str, Any] = {\"data\": nested_data}\n\n    if return_total_count:\n        total_count: int = await self.count(\n            db=db, joins_config=joins_config, **kwargs\n        )\n        response[\"total_count\"] = total_count\n\n    return response\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.select","title":"<code>select(schema_to_select=None, sort_columns=None, sort_orders=None, **kwargs)</code>  <code>async</code>","text":"<p>Constructs a SQL Alchemy <code>Select</code> statement with optional column selection, filtering, and sorting. This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks. Supported operators include:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or list of column names to sort the query results by. Must be used in conjunction with sort_orders.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order ('asc' or 'desc') or a list of sort orders, corresponding to each column in sort_columns. If not specified, defaults to ascending order for all sort_columns.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Selectable</code> <code>Select</code> <p>An SQL Alchemy <code>Select</code> statement object that can be executed or further modified.</p> <p>Examples:</p> <p>Selecting specific columns with filtering and sorting: <pre><code>stmt = await crud.select(\n    schema_to_select=UserReadSchema,\n    sort_columns=['age', 'name'],\n    sort_orders=['asc', 'desc'],\n    age__gt=18\n)\n</code></pre></p> <p>Creating a statement to select all users without any filters: <pre><code>stmt = await crud.select()\n</code></pre></p> <p>Selecting users with a specific role, ordered by name: <pre><code>stmt = await crud.select(\n    schema_to_select=UserReadSchema,\n    sort_columns='name',\n    role='admin'\n)\n</code></pre></p> <p>Note:     This method does not execute the generated SQL statement.     Use <code>db.execute(stmt)</code> to run the query and fetch results.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def select(\n    self,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs,\n) -&gt; Select:\n    \"\"\"\n    Constructs a SQL Alchemy `Select` statement with optional column selection, filtering, and sorting.\n    This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n    Supported operators include:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        schema_to_select: Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.\n        sort_columns: A single column name or list of column names to sort the query results by. Must be used in conjunction with sort_orders.\n        sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders, corresponding to each column in sort_columns. If not specified, defaults to ascending order for all sort_columns.\n\n    Returns:\n        Selectable: An SQL Alchemy `Select` statement object that can be executed or further modified.\n\n    Examples:\n        Selecting specific columns with filtering and sorting:\n        ```python\n        stmt = await crud.select(\n            schema_to_select=UserReadSchema,\n            sort_columns=['age', 'name'],\n            sort_orders=['asc', 'desc'],\n            age__gt=18\n        )\n        ```\n\n        Creating a statement to select all users without any filters:\n        ```python\n        stmt = await crud.select()\n        ```\n\n        Selecting users with a specific role, ordered by name:\n        ```python\n        stmt = await crud.select(\n            schema_to_select=UserReadSchema,\n            sort_columns='name',\n            role='admin'\n        )\n        ```\n    Note:\n        This method does not execute the generated SQL statement.\n        Use `db.execute(stmt)` to run the query and fetch results.\n    \"\"\"\n    to_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    filters = self._parse_filters(**kwargs)\n    stmt = select(*to_select).filter(*filters)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n    return stmt\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.update","title":"<code>update(db, object, allow_multiple=False, commit=True, **kwargs)</code>  <code>async</code>","text":"<p>Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update. It supports advanced filtering through comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to),     '__ne' (not equal),     '__in' (included in [tuple, list or set]),     '__not_in' (not included in [tuple, list or set]).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>object</code> <code>Union[UpdateSchemaType, dict[str, Any]]</code> <p>A Pydantic schema or dictionary containing the update data.</p> required <code>allow_multiple</code> <code>bool</code> <p>If True, allows updating multiple records that match the filters. If False, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If True, commits the transaction immediately. Default is True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is False and more than one record matches the filters.</p> <code>ValueError</code> <p>If extra fields not present in the model are provided in the update data.</p> <p>Examples:</p> <p>Update a user's email based on their ID: <pre><code>update(db, {'email': 'new_email@example.com'}, id=1)\n</code></pre></p> <p>Update users' statuses to 'inactive' where age is greater than 30 and allow updates to multiple records: <pre><code>update(db, {'status': 'inactive'}, allow_multiple=True, age__gt=30)\n</code></pre></p> <p>Update a user's username excluding specific user ID and prevent multiple updates: <pre><code>update(db, {'username': 'new_username'}, id__ne=1, allow_multiple=False)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def update(\n    self,\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n    It supports advanced filtering through comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to),\n        '__ne' (not equal),\n        '__in' (included in [tuple, list or set]),\n        '__not_in' (not included in [tuple, list or set]).\n\n    Args:\n        db: The database session to use for the operation.\n        object: A Pydantic schema or dictionary containing the update data.\n        allow_multiple: If True, allows updating multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n        commit: If True, commits the transaction immediately. Default is True.\n        **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n    Returns:\n        None\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n        ValueError: If extra fields not present in the model are provided in the update data.\n\n    Examples:\n        Update a user's email based on their ID:\n        ```python\n        update(db, {'email': 'new_email@example.com'}, id=1)\n        ```\n\n        Update users' statuses to 'inactive' where age is greater than 30 and allow updates to multiple records:\n        ```python\n        update(db, {'status': 'inactive'}, allow_multiple=True, age__gt=30)\n        ```\n\n        Update a user's username excluding specific user ID and prevent multiple updates:\n        ```python\n        update(db, {'username': 'new_username'}, id__ne=1, allow_multiple=False)\n        ```\n    \"\"\"\n    if not allow_multiple and (total_count := await self.count(db, **kwargs)) &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to update, found {total_count}.\"\n        )\n\n    if isinstance(object, dict):\n        update_data = object\n    else:\n        update_data = object.model_dump(exclude_unset=True)\n\n    updated_at_col = getattr(self.model, self.updated_at_column, None)\n    if updated_at_col:\n        update_data[self.updated_at_column] = datetime.now(timezone.utc)\n\n    update_data_keys = set(update_data.keys())\n    model_columns = {column.name for column in inspect(self.model).c}\n    extra_fields = update_data_keys - model_columns\n    if extra_fields:\n        raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n    filters = self._parse_filters(**kwargs)\n    stmt = update(self.model).filter(*filters).values(update_data)\n\n    await db.execute(stmt)\n    if commit:\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.upsert","title":"<code>upsert(db, instance, schema_to_select=None, return_as_model=False)</code>  <code>async</code>","text":"<p>Update the instance or create it if it doesn't exists. Note: This method will perform two transactions to the database (get and create or update).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>instance</code> <code>Union[UpdateSchemaType, type[BaseModel]]</code> <p>A Pydantic schema representing the instance.</p> required <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Optional Pydantic schema for selecting specific columns. Defaults to None.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>Union[BaseModel, Dict[str, Any], None]</code> <p>the created or updated instance</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def upsert(\n    self,\n    db: AsyncSession,\n    instance: Union[UpdateSchemaType, CreateSchemaType],\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n) -&gt; Union[BaseModel, Dict[str, Any], None]:\n    \"\"\"Update the instance or create it if it doesn't exists.\n    Note: This method will perform two transactions to the database (get and create or update).\n\n    Args:\n        db (AsyncSession): The database session to use for the operation.\n        instance (Union[UpdateSchemaType, type[BaseModel]]): A Pydantic schema representing the instance.\n        schema_to_select (Optional[type[BaseModel]], optional): Optional Pydantic schema for selecting specific columns. Defaults to None.\n        return_as_model (bool, optional): If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n\n    Returns:\n        BaseModel: the created or updated instance\n    \"\"\"\n    _pks = self._get_pk_dict(instance)\n    schema_to_select = schema_to_select or type(instance)\n    db_instance = await self.get(\n        db,\n        schema_to_select=schema_to_select,\n        return_as_model=return_as_model,\n        **_pks,\n    )\n    if db_instance is None:\n        db_instance = await self.create(db, instance)  # type: ignore\n        db_instance = schema_to_select.model_validate(\n            db_instance, from_attributes=True\n        )\n    else:\n        await self.update(db, instance)  # type: ignore\n        db_instance = await self.get(\n            db,\n            schema_to_select=schema_to_select,\n            return_as_model=return_as_model,\n            **_pks,\n        )\n\n    return db_instance\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Welcome to the API Reference section of our documentation. This section provides detailed information about the various classes, functions, and modules that make up our application. Whether you are looking to extend the application, integrate with it, or simply explore its capabilities, this section will guide you through the intricacies of our codebase.</p>"},{"location":"api/overview/#key-components","title":"Key Components","text":"<p>Our application's API is comprised of several key components, each serving a specific purpose:</p> <ol> <li> <p>FastCRUD Class: This class is at the heart of our CRUD (Create, Read, Update, Delete) operations. It provides a convenient and efficient way to interact with our database models.</p> <ul> <li>FastCRUD Class Reference</li> </ul> </li> <li> <p>EndpointCreator Class: A utility class for creating and registering CRUD endpoints in a FastAPI application. It simplifies the addition of standard CRUD endpoints to your FastAPI router.</p> <ul> <li>EndpointCreator Class Reference</li> </ul> </li> <li> <p>crud_router Function: A function that creates and configures a FastAPI router with CRUD endpoints for a specific model. It's a quick way to add standard CRUD operations to your models.</p> <ul> <li>CRUD Router Function Reference</li> </ul> </li> <li> <p>paginated Module: A a utility module for offset pagination related functions.</p> <ul> <li>Pagination Module Reference</li> </ul> </li> </ol>"},{"location":"api/overview/#usage","title":"Usage","text":"<p>Each component is documented with its own dedicated page, where you can find detailed information about its methods, parameters, return types, and usage examples. These pages are designed to provide you with all the information you need to understand and work with our API effectively.</p>"},{"location":"api/overview/#contribution","title":"Contribution","text":"<p>If you wish to contribute to the development of our API, please refer to our Contributing Guidelines. We welcome contributions of all forms, from bug fixes to feature development.</p>"},{"location":"api/overview/#feedback","title":"Feedback","text":"<p>Your feedback is crucial in helping us improve this documentation. If you have any suggestions, corrections, or queries, please reach out to us.</p> <p>Navigate through each section for detailed documentation of our API components.</p>"},{"location":"api/paginated/","title":"Paginated Module Reference","text":"<p><code>paginated</code> is a utility module for offset pagination related functions.</p>"},{"location":"api/paginated/#function-definition","title":"Function Definition","text":""},{"location":"api/paginated/#fastcrud.paginated.compute_offset","title":"<code>compute_offset(page, items_per_page)</code>","text":"<p>Calculate the offset for pagination based on the given page number and items per page.</p> <p>The offset represents the starting point in a dataset for the items on a given page. For example, if each page displays 10 items and you want to display page 3, the offset will be 20, meaning the display should start with the 21st item.</p>"},{"location":"api/paginated/#fastcrud.paginated.compute_offset--parameters","title":"Parameters","text":"<p>page : int     The current page number. Page numbers should start from 1. items_per_page : int     The number of items to be displayed on each page.</p>"},{"location":"api/paginated/#fastcrud.paginated.compute_offset--returns","title":"Returns","text":"<p>int     The calculated offset.</p>"},{"location":"api/paginated/#fastcrud.paginated.compute_offset--examples","title":"Examples","text":"<p>offset(1, 10) 0 offset(3, 10) 20</p> Source code in <code>fastcrud/paginated/helper.py</code> <pre><code>def compute_offset(page: int, items_per_page: int) -&gt; int:\n    \"\"\"Calculate the offset for pagination based on the given page number and items per page.\n\n    The offset represents the starting point in a dataset for the items on a given page.\n    For example, if each page displays 10 items and you want to display page 3, the offset will be 20,\n    meaning the display should start with the 21st item.\n\n    Parameters\n    ----------\n    page : int\n        The current page number. Page numbers should start from 1.\n    items_per_page : int\n        The number of items to be displayed on each page.\n\n    Returns\n    -------\n    int\n        The calculated offset.\n\n    Examples\n    --------\n    &gt;&gt;&gt; offset(1, 10)\n    0\n    &gt;&gt;&gt; offset(3, 10)\n    20\n    \"\"\"\n    return (page - 1) * items_per_page\n</code></pre>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response","title":"<code>paginated_response(crud_data, page, items_per_page)</code>","text":"<p>Create a paginated response based on the provided data and pagination parameters.</p>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response--parameters","title":"Parameters","text":"<p>crud_data : ListResponse[SchemaType]     Data to be paginated, including the list of items and total count. page : int     Current page number. items_per_page : int     Number of items per page.</p>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response--returns","title":"Returns","text":"<p>dict[str, Any]     A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.</p>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response--note","title":"Note","text":"<p>The function does not actually paginate the data but formats the response to indicate pagination metadata.</p> Source code in <code>fastcrud/paginated/response.py</code> <pre><code>def paginated_response(\n    crud_data: dict, page: int, items_per_page: int\n) -&gt; dict[str, Any]:\n    \"\"\"Create a paginated response based on the provided data and pagination parameters.\n\n    Parameters\n    ----------\n    crud_data : ListResponse[SchemaType]\n        Data to be paginated, including the list of items and total count.\n    page : int\n        Current page number.\n    items_per_page : int\n        Number of items per page.\n\n    Returns\n    -------\n    dict[str, Any]\n        A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.\n\n    Note\n    ----\n    The function does not actually paginate the data but formats the response to indicate pagination metadata.\n    \"\"\"\n    return {\n        \"data\": crud_data[\"data\"],\n        \"total_count\": crud_data[\"total_count\"],\n        \"has_more\": (page * items_per_page) &lt; crud_data[\"total_count\"],\n        \"page\": page,\n        \"items_per_page\": items_per_page,\n    }\n</code></pre>"},{"location":"community/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at igor.magalhaes.r@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/CONTRIBUTING/","title":"Contributing to FastAPI-boilerplate","text":"<p>Thank you for your interest in contributing to FastAPI-boilerplate! This guide is meant to make it easy for you to get started. Contributions are appreciated, even if just reporting bugs, documenting stuff or answering questions. To contribute with a feature:</p>"},{"location":"community/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":""},{"location":"community/CONTRIBUTING/#cloning-the-repository","title":"Cloning the Repository","text":"<p>Start by forking and cloning the FastAPI-boilerplate repository:</p> <ol> <li>Fork the Repository: Begin by forking the project repository. You can do this by visiting https://github.com/igormagalhaesr/FastAPI-boilerplate and clicking the \"Fork\" button.</li> <li>Create a Feature Branch: Once you've forked the repo, create a branch for your feature by running <code>git checkout -b feature/fooBar</code>.</li> <li>Testing Changes: Ensure that your changes do not break existing functionality by running tests. In the root folder, execute poetry run <code>python -m pytest</code> to run the tests.</li> </ol>"},{"location":"community/CONTRIBUTING/#using-poetry-for-dependency-management","title":"Using Poetry for Dependency Management","text":"<p>FastAPI-boilerplate uses Poetry for managing dependencies. If you don't have Poetry installed, follow the instructions on the official Poetry website.</p> <p>Once Poetry is installed, navigate to the cloned repository and install the dependencies: <pre><code>cd FastAPI-boilerplate\npoetry install\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#activating-the-virtual-environment","title":"Activating the Virtual Environment","text":"<p>Poetry creates a virtual environment for your project. Activate it using:</p> <pre><code>poetry shell\n</code></pre>"},{"location":"community/CONTRIBUTING/#making-contributions","title":"Making Contributions","text":""},{"location":"community/CONTRIBUTING/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow PEP 8 guidelines.</li> <li>Write meaningful tests for new features or bug fixes.</li> </ul>"},{"location":"community/CONTRIBUTING/#testing-with-pytest","title":"Testing with Pytest","text":"<p>FastAPI-boilerplate uses pytest for testing. Run tests using: <pre><code>poetry run pytest\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#linting","title":"Linting","text":"<p>Use mypy for type checking: <pre><code>mypy src\n</code></pre></p> <p>Use ruff for style: <pre><code>ruff check --fix\nruff format\n</code></pre></p> <p>Ensure your code passes linting before submitting.</p>"},{"location":"community/CONTRIBUTING/#using-pre-commit-for-better-code-quality","title":"Using pre-commit for Better Code Quality","text":"<p>It helps in identifying simple issues before submission to code review. By running automated checks, pre-commit can ensure code quality and consistency.</p> <ol> <li>Install Pre-commit:</li> <li>Installation: Install pre-commit in your development environment. Use the command <code>pip install pre-commit</code>.</li> <li>Setting Up Hooks: After installing pre-commit, set up the hooks with <code>pre-commit install</code>. This command will install hooks into your .git/ directory which will automatically check your commits for issues.</li> <li>Committing Your Changes:    After making your changes, use <code>git commit -am 'Add some fooBar'</code> to commit them. Pre-commit will run automatically on your files when you commit, ensuring that they meet the required standards.    Note: If pre-commit identifies issues, it may block your commit. Fix these issues and commit again. This ensures that all contributions are of high quality.</li> <li>Pushing Changes and Creating Pull Request:    Push your changes to the branch using <code>git push origin feature/fooBar</code>.    Visit your fork on GitHub and create a new Pull Request to the main repository.</li> </ol>"},{"location":"community/CONTRIBUTING/#additional-notes","title":"Additional Notes","text":"<p>Stay Updated: Keep your fork updated with the main repository to avoid merge conflicts. Regularly fetch and merge changes from the upstream repository. Adhere to Project Conventions: Follow the coding style, conventions, and commit message guidelines of the project. Open Communication: Feel free to ask questions or discuss your ideas by opening an issue or in discussions.</p>"},{"location":"community/CONTRIBUTING/#submitting-your-contributions","title":"Submitting Your Contributions","text":""},{"location":"community/CONTRIBUTING/#creating-a-pull-request","title":"Creating a Pull Request","text":"<p>After making your changes:</p> <ul> <li>Push your changes to your fork.</li> <li>Open a pull request with a clear description of your changes.</li> <li>Update the README.md if necessary.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-reviews","title":"Code Reviews","text":"<ul> <li>Address any feedback from code reviews.</li> <li>Once approved, your contributions will be merged into the main branch.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please adhere to our Code of Conduct to maintain a welcoming and inclusive environment.</p> <p>Thank you for contributing to FastAPI-boilerplate\ud83d\ude80</p>"},{"location":"community/LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Igor Magalh\u00e3es</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"community/overview/","title":"Community Overview","text":"<p>Welcome to the project's community hub. Here, you'll find essential resources and guidelines that are crucial for contributing to and participating in the project. Please take the time to familiarize yourself with the following documents:</p>"},{"location":"community/overview/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Contributing</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"community/overview/#contributing","title":"Contributing","text":"<p>View the Contributing Guidelines</p> <p>Interested in contributing to the project? Great! The contributing guidelines will provide you with all the information you need to get started. This includes how to submit issues, propose changes, and the process for submitting pull requests.</p>"},{"location":"community/overview/#code-of-conduct","title":"Code of Conduct","text":"<p>View the Code of Conduct</p> <p>The Code of Conduct outlines the standards and behaviors expected of our community members. It's crucial to ensure a welcoming and inclusive environment for everyone. Please take the time to read and adhere to these guidelines.</p>"},{"location":"community/overview/#license","title":"License","text":"<p>View the License</p> <p>The license document outlines the terms under which our project can be used, modified, and distributed. Understanding the licensing is important for both users and contributors of the project.</p> <p>Thank you for being a part of our community and for contributing to our project's success!</p>"},{"location":"usage/crud/","title":"Using FastCRUD for Enhanced CRUD Operations","text":"<p>FastCRUD is a versatile tool for handling CRUD (Create, Read, Update, Delete) operations in FastAPI applications with SQLAlchemy models. It leverages Pydantic schemas for data validation and serialization, offering a streamlined approach to database interactions.</p>"},{"location":"usage/crud/#key-features","title":"Key Features","text":"<ul> <li>Simplified CRUD operations with SQLAlchemy models.</li> <li>Data validation and serialization using Pydantic.</li> <li>Support for complex queries including joins and pagination.</li> </ul>"},{"location":"usage/crud/#getting-started","title":"Getting Started","text":""},{"location":"usage/crud/#step-1-define-models-and-schemas","title":"Step 1: Define Models and Schemas","text":"<p>Define your SQLAlchemy models and Pydantic schemas for data representation.</p> <pre><code># SQLAlchemy models and Pydantic schema definitions\n</code></pre>"},{"location":"usage/crud/#step-2-initialize-fastcrud","title":"Step 2: Initialize FastCRUD","text":"<p>Create a FastCRUD instance for your model to handle CRUD operations.</p> <pre><code>from fastcrud import FastCRUD\n\n# Creating a FastCRUD instance\nmy_model_crud = FastCRUD(MyModel)\n</code></pre>"},{"location":"usage/crud/#step-3-pick-your-method","title":"Step 3: Pick your Method","text":"<p>Then you just pick the method you need and use it like this:</p> <pre><code># Creating a new record\nnew_record = await my_model_crud.create(db_session, create_schema_instance)\n</code></pre> <p>More on available methods below.</p>"},{"location":"usage/crud/#understanding-fastcrud-methods","title":"Understanding FastCRUD Methods","text":"<p>FastCRUD offers a comprehensive suite of methods for CRUD operations, each designed to handle different aspects of database interactions efficiently.</p>"},{"location":"usage/crud/#1-create","title":"1. Create","text":"<pre><code>create(\n    db: AsyncSession,\n    object: CreateSchemaType,\n    commit: bool = True\n) -&gt; ModelType\n</code></pre> <p>Purpose: To create a new record in the database. Usage Example: Creates an item with name 'New Item'.</p> <pre><code>new_item = await item_crud.create(db, ItemCreateSchema(name=\"New Item\"))\n</code></pre> <p>Warning</p> <p>Note that naive <code>datetime</code> such as <code>datetime.utcnow</code> is not supported by <code>FastCRUD</code> as it was deprecated.</p> <p>Use timezone aware <code>datetime</code>, such as <code>datetime.now(UTC)</code> instead.</p>"},{"location":"usage/crud/#2-get","title":"2. Get","text":"<pre><code>get(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any\n) -&gt; Optional[Union[dict, BaseModel]]\n</code></pre> <p>Purpose: To fetch a single record based on filters, with an option to select specific columns using a Pydantic schema. Usage Example: Fetches the item with item_id as its id.</p> <pre><code>item = await item_crud.get(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#3-exists","title":"3. Exists","text":"<pre><code>exists(\n    db: AsyncSession,\n    **kwargs: Any\n) -&gt; bool\n</code></pre> <p>Purpose: To check if a record exists based on provided filters. Usage Example: Checks whether an item with name 'Existing Item' exists.</p> <pre><code>exists = await item_crud.exists(db, name=\"Existing Item\")\n</code></pre>"},{"location":"usage/crud/#4-count","title":"4. Count","text":"<pre><code>count(\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any\n) -&gt; int\n</code></pre> <p>Purpose: To count the number of records matching provided filters. Usage Example: Counts the number of items with the 'Books' category.</p> <pre><code>count = await item_crud.count(db, category=\"Books\")\n</code></pre>"},{"location":"usage/crud/#5-get-multi","title":"5. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records with optional sorting, pagination, and model conversion. Usage Example: Fetches a subset of 5 items, starting from the 11th item in the database.</p> <pre><code>items = await item_crud.get_multi(db, offset=10, limit=5)\n</code></pre>"},{"location":"usage/crud/#6-update","title":"6. Update","text":"<pre><code>update(\n    db: AsyncSession, \n    object: Union[UpdateSchemaType, dict[str, Any]], \n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To update an existing record in the database. Usage Example: Updates the description of the item with item_id as its id.</p> <pre><code>await item_crud.update(db, ItemUpdateSchema(description=\"Updated\"), id=item_id)\n</code></pre>"},{"location":"usage/crud/#7-delete","title":"7. Delete","text":"<pre><code>delete(\n    db: AsyncSession, \n    db_row: Optional[Row] = None, \n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To delete a record from the database, with support for soft delete. Usage Example: Deletes the item with item_id as its id, performs a soft delete if the model has the 'is_deleted' column.</p> <pre><code>await item_crud.delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#8-hard-delete","title":"8. Hard Delete","text":"<pre><code>db_delete(\n    db: AsyncSession, \n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To hard delete a record from the database. Usage Example: Hard deletes the item with item_id as its id.</p> <pre><code>await item_crud.db_delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#advanced-methods-for-complex-queries-and-joins","title":"Advanced Methods for Complex Queries and Joins","text":"<p>FastCRUD extends its functionality with advanced methods tailored for complex query operations and handling joins. These methods cater to specific use cases where more sophisticated data retrieval and manipulation are required.</p>"},{"location":"usage/crud/#1-get-multi","title":"1. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records based on specified filters, with options for sorting and pagination. Usage Example: Gets the first 10 items sorted by 'name' in ascending order.</p> <pre><code>items = await item_crud.get_multi(db, offset=0, limit=10, sort_columns=['name'], sort_orders=['asc'])\n</code></pre>"},{"location":"usage/crud/#2-get-joined","title":"2. Get Joined","text":"<pre><code>get_joined(\n    db: AsyncSession,\n    join_model: Optional[type[DeclarativeBase]] = None,\n    join_prefix: Optional[str] = None,\n    join_on: Optional[Union[Join, BinaryExpression]] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    join_filters: Optional[dict] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    nest_joins: bool = False,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]\n</code></pre> <p>Purpose: To fetch a single record with one or multiple joins on other models. Usage Example: Fetches order details for a specific order by joining with the Customer table, selecting specific columns as defined in OrderSchema and CustomerSchema.</p> <pre><code>order_details = await order_crud.get_joined(\n    db,\n    join_model=Customer,\n    schema_to_select=OrderSchema,\n    join_schema_to_select=CustomerSchema,\n    id=order_id\n)\n</code></pre>"},{"location":"usage/crud/#3-get-multi-joined","title":"3. Get Multi Joined","text":"<pre><code>get_multi_joined(\n    db: AsyncSession,\n    join_model: Optional[type[ModelType]] = None,\n    join_prefix: Optional[str] = None,\n    join_on: Optional[Any] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    alias: Optional[str] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    joins_config: Optional[list[JoinConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Similar to <code>get_joined</code>, but for fetching multiple records. Usage Example: Retrieves a paginated list of orders (up to 5), joined with the Customer table, using specified schemas for selective column retrieval from both tables.</p> <pre><code>orders = await order_crud.get_multi_joined(\n    db,\n    join_model=Customer,\n    offset=0,\n    limit=5,\n    schema_to_select=OrderSchema,\n    join_schema_to_select=CustomerSchema\n)\n</code></pre>"},{"location":"usage/crud/#4-get-multi-by-cursor","title":"4. Get Multi By Cursor","text":"<pre><code>get_multi_by_cursor(\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Implements cursor-based pagination for efficient data retrieval in large datasets. Usage Example: Fetches the next 10 items after the last cursor for efficient pagination, sorted by creation date in descending order.</p> <pre><code>paginated_items = await item_crud.get_multi_by_cursor(\n    db,\n    cursor=last_cursor,\n    limit=10,\n    sort_column='created_at',\n    sort_order='desc'\n)\n</code></pre>"},{"location":"usage/crud/#5-select","title":"5. Select","text":"<pre><code>async def select(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any\n) -&gt; Selectable\n</code></pre> <p>Purpose: Constructs a SQL Alchemy Select statement with optional column selection, filtering, and sorting. Usage Example: Selects all items, filtering by 'name' and sorting by 'id'. Returns the <code>select</code> statement.</p> <pre><code>stmt = await item_crud.select(schema_to_select=ItemSchema, sort_columns='id', name='John')\n# Note: This method returns a SQL Alchemy Selectable object, not the actual query result.\n</code></pre>"},{"location":"usage/crud/#6-count-for-joined-models","title":"6. Count for Joined Models","text":"<pre><code>count(\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any\n) -&gt; int\n</code></pre> <p>Purpose: To count records that match specified filters, especially useful in scenarios involving joins between models. This method supports counting unique entities across relationships, a common requirement in many-to-many or complex relationships. Usage Example: Count the number of unique projects a participant is involved in, considering a many-to-many relationship between Project and Participant models.</p> <pre><code># Assuming a Project model related to a Participant model through a many-to-many relationship\nprojects_count = await project_crud.count(\n    db=session,\n    joins_config=[\n        JoinConfig(\n            model=Participant,\n            join_on=ProjectsParticipantsAssociation.project_id == Project.id,\n            join_type=\"inner\"\n        )\n    ],\n    participant_id=specific_participant_id\n)\n</code></pre>"},{"location":"usage/crud/#error-handling","title":"Error Handling","text":"<p>FastCRUD provides mechanisms to handle common database errors, ensuring robust API behavior.</p>"},{"location":"usage/endpoint/","title":"Automatic Endpoint Creation with crud_router","text":"<p>This section of the documentation explains how to use the <code>crud_router</code> utility function from the FastCRUD package for automatic endpoint creation in a FastAPI application. The <code>crud_router</code> simplifies the process of creating standard CRUD (Create, Read, Update, Delete) endpoints for your models.</p>"},{"location":"usage/endpoint/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you have FastAPI and FastCRUD installed in your environment. FastCRUD streamlines interactions with the database using SQLAlchemy models and Pydantic schemas.</p> <p>Warning</p> <pre><code>For now, your primary column in the database model must be named `id`.\n</code></pre>"},{"location":"usage/endpoint/#using-crud_router","title":"Using <code>crud_router</code>","text":""},{"location":"usage/endpoint/#step-1-define-your-model-and-schema","title":"Step 1: Define Your Model and Schema","text":"<p>First, define your SQLAlchemy model and corresponding Pydantic schemas for creating and updating data.</p> models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application, you can optionally set up a custom FastCRUD instance as well. This involves configuring the database connection.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n</code></pre>"},{"location":"usage/endpoint/#step-3-use-crud_router-to-create-endpoints","title":"Step 3: Use <code>crud_router</code> to Create Endpoints","text":"<pre><code># CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemCreateSchema,\n    update_schema=ItemUpdateSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"usage/endpoint/#available-endpoints","title":"Available Endpoints","text":"<p>For a comprehensive list of all available endpoints, read the advanced section.</p>"},{"location":"usage/endpoint/#usage-and-testing","title":"Usage and Testing","text":"<p>Once the application is running, you can test the automatically created endpoints using tools like Swagger UI, which FastAPI provides by default. The endpoints for creating, reading, updating, and deleting Item instances are now accessible at /items.</p>"},{"location":"usage/endpoint/#using-endpointcreator-directly","title":"Using <code>EndpointCreator</code> Directly","text":"<p>Using the <code>EndpointCreator</code> class in FastCRUD is a more flexible way to add CRUD endpoints to a FastAPI application.</p>"},{"location":"usage/endpoint/#step-1-define-your-model-and-schema_1","title":"Step 1: Define Your Model and Schema","text":"<p>Define your SQLAlchemy models and corresponding Pydantic schemas for data validation.</p> models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud_1","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application and FastCRUD instances. This involves configuring the database connection and creating a CRUD instance for your model.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\ncrud = FastCRUD(Item)\n</code></pre>"},{"location":"usage/endpoint/#step-3-initialize-endpointcreator","title":"Step 3: Initialize <code>EndpointCreator</code>","text":"<p>Create an instance of EndpointCreator by passing the necessary parameters, including your model, session, CRUD instance, and schemas.</p> <pre><code>from fastcrud import EndpointCreator\n\n# Initialize EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=get_session,\n    model=YourModel,\n    create_schema=YourCreateSchema,\n    update_schema=YourUpdateSchema,\n    delete_schema=YourDeleteSchema,\n    path=\"/yourmodelpath\",\n    tags=[\"YourModelTag\"]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-4-add-custom-endpoints","title":"Step 4: Add Custom Endpoints","text":"<p>Add custom endpoints using EndpointCreator. You can inject dependencies as needed.</p> <pre><code># Example of adding custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[custom_dependency],\n    update_deps=[another_custom_dependency]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-5-include-the-router-in-your-application","title":"Step 5: Include the Router in Your Application","text":"<p>Finally, include the router from the EndpointCreator in your FastAPI application.</p> <pre><code>app.include_router(endpoint_creator.router)\n</code></pre>"},{"location":"usage/endpoint/#advanced-customization","title":"Advanced Customization","text":"<p>You can override the default methods in EndpointCreator for more control over the CRUD operations. You can also specify the operations you want to include. Read more in the advanced section.</p>"},{"location":"usage/endpoint/#conclusion","title":"Conclusion","text":"<p>By following these steps, you can quickly set up CRUD endpoints for your models in a FastAPI application using crud_router or EndpointCreator. This utility function reduces boilerplate code and increases development efficiency by automating the creation of standard API endpoints.</p>"},{"location":"usage/overview/","title":"Usage Overview","text":"<p>The Usage section of our documentation provides comprehensive guides on how to effectively use key features of our application. This section is divided into various topics, each focusing on a specific aspect of usage, ensuring that you have all the information you need to leverage the full potential of our tools and functionalities.</p>"},{"location":"usage/overview/#key-topics","title":"Key Topics","text":""},{"location":"usage/overview/#1-automatic-endpoint-creation-with-crud_router","title":"1. Automatic Endpoint Creation with crud_router","text":"<p>This guide covers the use of <code>crud_router</code> for automatic endpoint creation in FastAPI applications. It provides a step-by-step approach to streamline the creation of standard CRUD endpoints.</p> <ul> <li>Automatic Endpoint Creation Guide</li> </ul>"},{"location":"usage/overview/#2-enhanced-crud-operations-with-fastcrud","title":"2. Enhanced CRUD Operations with FastCRUD","text":"<p>Learn how to use the <code>FastCRUD</code> class for enhanced CRUD operations. This guide delves into the functionalities offered by <code>FastCRUD</code>, including advanced query capabilities, pagination, and error handling.</p> <ul> <li>FastCRUD Usage Guide</li> </ul>"},{"location":"usage/overview/#getting-started","title":"Getting Started","text":"<p>To make the most out of these guides, we recommend familiarizing yourself with FastAPI and SQLAlchemy basics, as our application leverages these frameworks extensively.</p>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>If you have suggestions or contributions to these guides, please refer to our Contributing Guidelines. We appreciate your input in improving our documentation.</p>"}]}